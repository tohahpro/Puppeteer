/**********************************************************************
 * Auto-generated by protocol-dts-generator.ts, do not edit manually. *
 **********************************************************************/

/**
 * The Chrome DevTools Protocol.
 * @public
 */
export namespace Protocol {

    export type integer = number

    /**
     * This domain is deprecated - use Runtime or Log instead.
     */
    export namespace Console {

        export const enum ConsoleMessageSource {
            XML = 'xml',
            Javascript = 'javascript',
            Network = 'network',
            ConsoleAPI = 'console-api',
            Storage = 'storage',
            Appcache = 'appcache',
            Rendering = 'rendering',
            Security = 'security',
            Other = 'other',
            Deprecation = 'deprecation',
            Worker = 'worker',
        }

        export const enum ConsoleMessageLevel {
            Log = 'log',
            Warning = 'warning',
            Error = 'error',
            Debug = 'debug',
            Info = 'info',
        }

        /**
         * Console message.
         */
        export interface ConsoleMessage {
            /**
             * Message source. (ConsoleMessageSource enum)
             */
            source: ('xml' | 'javascript' | 'network' | 'console-api' | 'storage' | 'appcache' | 'rendering' | 'security' | 'other' | 'deprecation' | 'worker');
            /**
             * Message severity. (ConsoleMessageLevel enum)
             */
            level: ('log' | 'warning' | 'error' | 'debug' | 'info');
            /**
             * Message text.
             */
            text: string;
            /**
             * URL of the message origin.
             */
            url?: string;
            /**
             * Line number in the resource that generated this message (1-based).
             */
            line?: integer;
            /**
             * Column number in the resource that generated this message (1-based).
             */
            column?: integer;
        }

        /**
         * Issued when new console message is added.
         */
        export interface MessageAddedEvent {
            /**
             * Console message that has been added.
             */
            message: ConsoleMessage;
        }
    }

    /**
     * Debugger domain exposes JavaScript debugging capabilities. It allows setting and removing
     * breakpoints, stepping through execution, exploring stack traces, etc.
     */
    export namespace Debugger {

        /**
         * Breakpoint identifier.
         */
        export type BreakpointId = string;

        /**
         * Call frame identifier.
         */
        export type CallFrameId = string;

        /**
         * Location in the source code.
         */
        export interface Location {
            /**
             * Script identifier as reported in the `Debugger.scriptParsed`.
             */
            scriptId: Runtime.ScriptId;
            /**
             * Line number in the script (0-based).
             */
            lineNumber: integer;
            /**
             * Column number in the script (0-based).
             */
            columnNumber?: integer;
        }

        /**
         * Location in the source code.
         */
        export interface ScriptPosition {
            lineNumber: integer;
            columnNumber: integer;
        }

        /**
         * Location range within one script.
         */
        export interface LocationRange {
            scriptId: Runtime.ScriptId;
            start: ScriptPosition;
            end: ScriptPosition;
        }

        /**
         * JavaScript call frame. Array of call frames form the call stack.
         */
        export interface CallFrame {
            /**
             * Call frame identifier. This identifier is only valid while the virtual machine is paused.
             */
            callFrameId: CallFrameId;
            /**
             * Name of the JavaScript function called on this call frame.
             */
            functionName: string;
            /**
             * Location in the source code.
             */
            functionLocation?: Location;
            /**
             * Location in the source code.
             */
            location: Location;
            /**
             * JavaScript script name or url.
             * Deprecated in favor of using the `location.scriptId` to resolve the URL via a previously
             * sent `Debugger.scriptParsed` event.
             */
            url: string;
            /**
             * Scope chain for this call frame.
             */
            scopeChain: Scope[];
            /**
             * `this` object for this call frame.
             */
            this: Runtime.RemoteObject;
            /**
             * The value being returned, if the function is at return point.
             */
            returnValue?: Runtime.RemoteObject;
            /**
             * Valid only while the VM is paused and indicates whether this frame
             * can be restarted or not. Note that a `true` value here does not
             * guarantee that Debugger#restartFrame with this CallFrameId will be
             * successful, but it is very likely.
             */
            canBeRestarted?: boolean;
        }

        export const enum ScopeType {
            Global = 'global',
            Local = 'local',
            With = 'with',
            Closure = 'closure',
            Catch = 'catch',
            Block = 'block',
            Script = 'script',
            Eval = 'eval',
            Module = 'module',
            WasmExpressionStack = 'wasm-expression-stack',
        }

        /**
         * Scope description.
         */
        export interface Scope {
            /**
             * Scope type. (ScopeType enum)
             */
            type: ('global' | 'local' | 'with' | 'closure' | 'catch' | 'block' | 'script' | 'eval' | 'module' | 'wasm-expression-stack');
            /**
             * Object representing the scope. For `global` and `with` scopes it represents the actual
             * object; for the rest of the scopes, it is artificial transient object enumerating scope
             * variables as its properties.
             */
            object: Runtime.RemoteObject;
            name?: string;
            /**
             * Location in the source code where scope starts
             */
            startLocation?: Location;
            /**
             * Location in the source code where scope ends
             */
            endLocation?: Location;
        }

        /**
         * Search match for resource.
         */
        export interface SearchMatch {
            /**
             * Line number in resource content.
             */
            lineNumber: number;
            /**
             * Line with match content.
             */
            lineContent: string;
        }

        export const enum BreakLocationType {
            DebuggerStatement = 'debuggerStatement',
            Call = 'call',
            Return = 'return',
        }

        export interface BreakLocation {
            /**
             * Script identifier as reported in the `Debugger.scriptParsed`.
             */
            scriptId: Runtime.ScriptId;
            /**
             * Line number in the script (0-based).
             */
            lineNumber: integer;
            /**
             * Column number in the script (0-based).
             */
            columnNumber?: integer;
            /**
             *  (BreakLocationType enum)
             */
            type?: ('debuggerStatement' | 'call' | 'return');
        }

        export interface WasmDisassemblyChunk {
            /**
             * The next chunk of disassembled lines.
             */
            lines: string[];
            /**
             * The bytecode offsets describing the start of each line.
             */
            bytecodeOffsets: integer[];
        }

        /**
         * Enum of possible script languages.
         */
        export type ScriptLanguage = ('JavaScript' | 'WebAssembly');

        export const enum DebugSymbolsType {
            None = 'None',
            SourceMap = 'SourceMap',
            EmbeddedDWARF = 'EmbeddedDWARF',
            ExternalDWARF = 'ExternalDWARF',
        }

        /**
         * Debug symbols available for a wasm script.
         */
        export interface DebugSymbols {
            /**
             * Type of the debug symbols. (DebugSymbolsType enum)
             */
            type: ('None' | 'SourceMap' | 'EmbeddedDWARF' | 'ExternalDWARF');
            /**
             * URL of the external symbol source.
             */
            externalURL?: string;
        }

        export const enum ContinueToLocationRequestTargetCallFrames {
            Any = 'any',
            Current = 'current',
        }

        export interface ContinueToLocationRequest {
            /**
             * Location to continue to.
             */
            location: Location;
            /**
             *  (ContinueToLocationRequestTargetCallFrames enum)
             */
            targetCallFrames?: ('any' | 'current');
        }

        export interface EnableRequest {
            /**
             * The maximum size in bytes of collected scripts (not referenced by other heap objects)
             * the debugger can hold. Puts no limit if parameter is omitted.
             */
            maxScriptsCacheSize?: number;
        }

        export interface EnableResponse {
            /**
             * Unique identifier of the debugger.
             */
            debuggerId: Runtime.UniqueDebuggerId;
        }

        export interface EvaluateOnCallFrameRequest {
            /**
             * Call frame identifier to evaluate on.
             */
            callFrameId: CallFrameId;
            /**
             * Expression to evaluate.
             */
            expression: string;
            /**
             * String object group name to put result into (allows rapid releasing resulting object handles
             * using `releaseObjectGroup`).
             */
            objectGroup?: string;
            /**
             * Specifies whether command line API should be available to the evaluated expression, defaults
             * to false.
             */
            includeCommandLineAPI?: boolean;
            /**
             * In silent mode exceptions thrown during evaluation are not reported and do not pause
             * execution. Overrides `setPauseOnException` state.
             */
            silent?: boolean;
            /**
             * Whether the result is expected to be a JSON object that should be sent by value.
             */
            returnByValue?: boolean;
            /**
             * Whether preview should be generated for the result.
             */
            generatePreview?: boolean;
            /**
             * Whether to throw an exception if side effect cannot be ruled out during evaluation.
             */
            throwOnSideEffect?: boolean;
            /**
             * Terminate execution after timing out (number of milliseconds).
             */
            timeout?: Runtime.TimeDelta;
        }

        export interface EvaluateOnCallFrameResponse {
            /**
             * Object wrapper for the evaluation result.
             */
            result: Runtime.RemoteObject;
            /**
             * Exception details.
             */
            exceptionDetails?: Runtime.ExceptionDetails;
        }

        export interface GetPossibleBreakpointsRequest {
            /**
             * Start of range to search possible breakpoint locations in.
             */
            start: Location;
            /**
             * End of range to search possible breakpoint locations in (excluding). When not specified, end
             * of scripts is used as end of range.
             */
            end?: Location;
            /**
             * Only consider locations which are in the same (non-nested) function as start.
             */
            restrictToFunction?: boolean;
        }

        export interface GetPossibleBreakpointsResponse {
            /**
             * List of the possible breakpoint locations.
             */
            locations: BreakLocation[];
        }

        export interface GetScriptSourceRequest {
            /**
             * Id of the script to get source for.
             */
            scriptId: Runtime.ScriptId;
        }

        export interface GetScriptSourceResponse {
            /**
             * Script source (empty in case of Wasm bytecode).
             */
            scriptSource: string;
            /**
             * Wasm bytecode. (Encoded as a base64 string when passed over JSON)
             */
            bytecode?: string;
        }

        export interface DisassembleWasmModuleRequest {
            /**
             * Id of the script to disassemble
             */
            scriptId: Runtime.ScriptId;
        }

        export interface DisassembleWasmModuleResponse {
            /**
             * For large modules, return a stream from which additional chunks of
             * disassembly can be read successively.
             */
            streamId?: string;
            /**
             * The total number of lines in the disassembly text.
             */
            totalNumberOfLines: integer;
            /**
             * The offsets of all function bodies, in the format [start1, end1,
             * start2, end2, ...] where all ends are exclusive.
             */
            functionBodyOffsets: integer[];
            /**
             * The first chunk of disassembly.
             */
            chunk: WasmDisassemblyChunk;
        }

        export interface NextWasmDisassemblyChunkRequest {
            streamId: string;
        }

        export interface NextWasmDisassemblyChunkResponse {
            /**
             * The next chunk of disassembly.
             */
            chunk: WasmDisassemblyChunk;
        }

        export interface GetWasmBytecodeRequest {
            /**
             * Id of the Wasm script to get source for.
             */
            scriptId: Runtime.ScriptId;
        }

        export interface GetWasmBytecodeResponse {
            /**
             * Script source. (Encoded as a base64 string when passed over JSON)
             */
            bytecode: string;
        }

        export interface GetStackTraceRequest {
            stackTraceId: Runtime.StackTraceId;
        }

        export interface GetStackTraceResponse {
            stackTrace: Runtime.StackTrace;
        }

        export interface PauseOnAsyncCallRequest {
            /**
             * Debugger will pause when async call with given stack trace is started.
             */
            parentStackTraceId: Runtime.StackTraceId;
        }

        export interface RemoveBreakpointRequest {
            breakpointId: BreakpointId;
        }

        export const enum RestartFrameRequestMode {
            StepInto = 'StepInto',
        }

        export interface RestartFrameRequest {
            /**
             * Call frame identifier to evaluate on.
             */
            callFrameId: CallFrameId;
            /**
             * The `mode` parameter must be present and set to 'StepInto', otherwise
             * `restartFrame` will error out. (RestartFrameRequestMode enum)
             */
            mode?: ('StepInto');
        }

        export interface RestartFrameResponse {
            /**
             * New stack trace.
             */
            callFrames: CallFrame[];
            /**
             * Async stack trace, if any.
             */
            asyncStackTrace?: Runtime.StackTrace;
            /**
             * Async stack trace, if any.
             */
            asyncStackTraceId?: Runtime.StackTraceId;
        }

        export interface ResumeRequest {
            /**
             * Set to true to terminate execution upon resuming execution. In contrast
             * to Runtime.terminateExecution, this will allows to execute further
             * JavaScript (i.e. via evaluation) until execution of the paused code
             * is actually resumed, at which point termination is triggered.
             * If execution is currently not paused, this parameter has no effect.
             */
            terminateOnResume?: boolean;
        }

        export interface SearchInContentRequest {
            /**
             * Id of the script to search in.
             */
            scriptId: Runtime.ScriptId;
            /**
             * String to search for.
             */
            query: string;
            /**
             * If true, search is case sensitive.
             */
            caseSensitive?: boolean;
            /**
             * If true, treats string parameter as regex.
             */
            isRegex?: boolean;
        }

        export interface SearchInContentResponse {
            /**
             * List of search matches.
             */
            result: SearchMatch[];
        }

        export interface SetAsyncCallStackDepthRequest {
            /**
             * Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async
             * call stacks (default).
             */
            maxDepth: integer;
        }

        export interface SetBlackboxPatternsRequest {
            /**
             * Array of regexps that will be used to check script url for blackbox state.
             */
            patterns: string[];
        }

        export interface SetBlackboxedRangesRequest {
            /**
             * Id of the script.
             */
            scriptId: Runtime.ScriptId;
            positions: ScriptPosition[];
        }

        export interface SetBreakpointRequest {
            /**
             * Location to set breakpoint in.
             */
            location: Location;
            /**
             * Expression to use as a breakpoint condition. When specified, debugger will only stop on the
             * breakpoint if this expression evaluates to true.
             */
            condition?: string;
        }

        export interface SetBreakpointResponse {
            /**
             * Id of the created breakpoint for further reference.
             */
            breakpointId: BreakpointId;
            /**
             * Location this breakpoint resolved into.
             */
            actualLocation: Location;
        }

        export const enum SetInstrumentationBreakpointRequestInstrumentation {
            BeforeScriptExecution = 'beforeScriptExecution',
            BeforeScriptWithSourceMapExecution = 'beforeScriptWithSourceMapExecution',
        }

        export interface SetInstrumentationBreakpointRequest {
            /**
             * Instrumentation name. (SetInstrumentationBreakpointRequestInstrumentation enum)
             */
            instrumentation: ('beforeScriptExecution' | 'beforeScriptWithSourceMapExecution');
        }

        export interface SetInstrumentationBreakpointResponse {
            /**
             * Id of the created breakpoint for further reference.
             */
            breakpointId: BreakpointId;
        }

        export interface SetBreakpointByUrlRequest {
            /**
             * Line number to set breakpoint at.
             */
            lineNumber: integer;
            /**
             * URL of the resources to set breakpoint on.
             */
            url?: string;
            /**
             * Regex pattern for the URLs of the resources to set breakpoints on. Either `url` or
             * `urlRegex` must be specified.
             */
            urlRegex?: string;
            /**
             * Script hash of the resources to set breakpoint on.
             */
            scriptHash?: string;
            /**
             * Offset in the line to set breakpoint at.
             */
            columnNumber?: integer;
            /**
             * Expression to use as a breakpoint condition. When specified, debugger will only stop on the
             * breakpoint if this expression evaluates to true.
             */
            condition?: string;
        }

        export interface SetBreakpointByUrlResponse {
            /**
             * Id of the created breakpoint for further reference.
             */
            breakpointId: BreakpointId;
            /**
             * List of the locations this breakpoint resolved into upon addition.
             */
            locations: Location[];
        }

        export interface SetBreakpointOnFunctionCallRequest {
            /**
             * Function object id.
             */
            objectId: Runtime.RemoteObjectId;
            /**
             * Expression to use as a breakpoint condition. When specified, debugger will
             * stop on the breakpoint if this expression evaluates to true.
             */
            condition?: string;
        }

        export interface SetBreakpointOnFunctionCallResponse {
            /**
             * Id of the created breakpoint for further reference.
             */
            breakpointId: BreakpointId;
        }

        export interface SetBreakpointsActiveRequest {
            /**
             * New value for breakpoints active state.
             */
            active: boolean;
        }

        export const enum SetPauseOnExceptionsRequestState {
            None = 'none',
            Caught = 'caught',
            Uncaught = 'uncaught',
            All = 'all',
        }

        export interface SetPauseOnExceptionsRequest {
            /**
             * Pause on exceptions mode. (SetPauseOnExceptionsRequestState enum)
             */
            state: ('none' | 'caught' | 'uncaught' | 'all');
        }

        export interface SetReturnValueRequest {
            /**
             * New return value.
             */
            newValue: Runtime.CallArgument;
        }

        export const enum SetScriptSourceResponseStatus {
            Ok = 'Ok',
            CompileError = 'CompileError',
            BlockedByActiveGenerator = 'BlockedByActiveGenerator',
            BlockedByActiveFunction = 'BlockedByActiveFunction',
            BlockedByTopLevelEsModuleChange = 'BlockedByTopLevelEsModuleChange',
        }

        export interface SetScriptSourceRequest {
            /**
             * Id of the script to edit.
             */
            scriptId: Runtime.ScriptId;
            /**
             * New content of the script.
             */
            scriptSource: string;
            /**
             * If true the change will not actually be applied. Dry run may be used to get result
             * description without actually modifying the code.
             */
            dryRun?: boolean;
            /**
             * If true, then `scriptSource` is allowed to change the function on top of the stack
             * as long as the top-most stack frame is the only activation of that function.
             */
            allowTopFrameEditing?: boolean;
        }

        export interface SetScriptSourceResponse {
            /**
             * New stack trace in case editing has happened while VM was stopped.
             */
            callFrames?: CallFrame[];
            /**
             * Whether current call stack  was modified after applying the changes.
             */
            stackChanged?: boolean;
            /**
             * Async stack trace, if any.
             */
            asyncStackTrace?: Runtime.StackTrace;
            /**
             * Async stack trace, if any.
             */
            asyncStackTraceId?: Runtime.StackTraceId;
            /**
             * Whether the operation was successful or not. Only `Ok` denotes a
             * successful live edit while the other enum variants denote why
             * the live edit failed. (SetScriptSourceResponseStatus enum)
             */
            status: ('Ok' | 'CompileError' | 'BlockedByActiveGenerator' | 'BlockedByActiveFunction' | 'BlockedByTopLevelEsModuleChange');
            /**
             * Exception details if any. Only present when `status` is `CompileError`.
             */
            exceptionDetails?: Runtime.ExceptionDetails;
        }

        export interface SetSkipAllPausesRequest {
            /**
             * New value for skip pauses state.
             */
            skip: boolean;
        }

        export interface SetVariableValueRequest {
            /**
             * 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch'
             * scope types are allowed. Other scopes could be manipulated manually.
             */
            scopeNumber: integer;
            /**
             * Variable name.
             */
            variableName: string;
            /**
             * New variable value.
             */
            newValue: Runtime.CallArgument;
            /**
             * Id of callframe that holds variable.
             */
            callFrameId: CallFrameId;
        }

        export interface StepIntoRequest {
            /**
             * Debugger will pause on the execution of the first async task which was scheduled
             * before next pause.
             */
            breakOnAsyncCall?: boolean;
            /**
             * The skipList specifies location ranges that should be skipped on step into.
             */
            skipList?: LocationRange[];
        }

        export interface StepOverRequest {
            /**
             * The skipList specifies location ranges that should be skipped on step over.
             */
            skipList?: LocationRange[];
        }

        /**
         * Fired when breakpoint is resolved to an actual script and location.
         */
        export interface BreakpointResolvedEvent {
            /**
             * Breakpoint unique identifier.
             */
            breakpointId: BreakpointId;
            /**
             * Actual breakpoint location.
             */
            location: Location;
        }

        export const enum PausedEventReason {
            Ambiguous = 'ambiguous',
            Assert = 'assert',
            CSPViolation = 'CSPViolation',
            DebugCommand = 'debugCommand',
            DOM = 'DOM',
            EventListener = 'EventListener',
            Exception = 'exception',
            Instrumentation = 'instrumentation',
            OOM = 'OOM',
            Other = 'other',
            PromiseRejection = 'promiseRejection',
            XHR = 'XHR',
            Step = 'step',
        }

        /**
         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
         */
        export interface PausedEvent {
            /**
             * Call stack the virtual machine stopped on.
             */
            callFrames: CallFrame[];
            /**
             * Pause reason. (PausedEventReason enum)
             */
            reason: ('ambiguous' | 'assert' | 'CSPViolation' | 'debugCommand' | 'DOM' | 'EventListener' | 'exception' | 'instrumentation' | 'OOM' | 'other' | 'promiseRejection' | 'XHR' | 'step');
            /**
             * Object containing break-specific auxiliary properties.
             */
            data?: any;
            /**
             * Hit breakpoints IDs
             */
            hitBreakpoints?: string[];
            /**
             * Async stack trace, if any.
             */
            asyncStackTrace?: Runtime.StackTrace;
            /**
             * Async stack trace, if any.
             */
            asyncStackTraceId?: Runtime.StackTraceId;
            /**
             * Never present, will be removed.
             */
            asyncCallStackTraceId?: Runtime.StackTraceId;
        }

        /**
         * Fired when virtual machine fails to parse the script.
         */
        export interface ScriptFailedToParseEvent {
            /**
             * Identifier of the script parsed.
             */
            scriptId: Runtime.ScriptId;
            /**
             * URL or name of the script parsed (if any).
             */
            url: string;
            /**
             * Line offset of the script within the resource with given URL (for script tags).
             */
            startLine: integer;
            /**
             * Column offset of the script within the resource with given URL.
             */
            startColumn: integer;
            /**
             * Last line of the script.
             */
            endLine: integer;
            /**
             * Length of the last line of the script.
             */
            endColumn: integer;
            /**
             * Specifies script creation context.
             */
            executionContextId: Runtime.ExecutionContextId;
            /**
             * Content hash of the script, SHA-256.
             */
            hash: string;
            /**
             * Embedder-specific auxiliary data likely matching {isDefault: boolean, type: 'default'|'isolated'|'worker', frameId: string}
             */
            executionContextAuxData?: any;
            /**
             * URL of source map associated with script (if any).
             */
            sourceMapURL?: string;
            /**
             * True, if this script has sourceURL.
             */
            hasSourceURL?: boolean;
            /**
             * True, if this script is ES6 module.
             */
            isModule?: boolean;
            /**
             * This script length.
             */
            length?: integer;
            /**
             * JavaScript top stack frame of where the script parsed event was triggered if available.
             */
            stackTrace?: Runtime.StackTrace;
            /**
             * If the scriptLanguage is WebAssembly, the code section offset in the module.
             */
            codeOffset?: integer;
            /**
             * The language of the script.
             */
            scriptLanguage?: Debugger.ScriptLanguage;
            /**
             * The name the embedder supplied for this script.
             */
            embedderName?: string;
        }

        /**
         * Fired when virtual machine parses script. This event is also fired for all known and uncollected
         * scripts upon enabling debugger.
         */
        export interface ScriptParsedEvent {
            /**
             * Identifier of the script parsed.
             */
            scriptId: Runtime.ScriptId;
            /**
             * URL or name of the script parsed (if any).
             */
            url: string;
            /**
             * Line offset of the script within the resource with given URL (for script tags).
             */
            startLine: integer;
            /**
             * Column offset of the script within the resource with given URL.
             */
            startColumn: integer;
            /**
             * Last line of the script.
             */
            endLine: integer;
            /**
             * Length of the last line of the script.
             */
            endColumn: integer;
            /**
             * Specifies script creation context.
             */
            executionContextId: Runtime.ExecutionContextId;
            /**
             * Content hash of the script, SHA-256.
             */
            hash: string;
            /**
             * Embedder-specific auxiliary data likely matching {isDefault: boolean, type: 'default'|'isolated'|'worker', frameId: string}
             */
            executionContextAuxData?: any;
            /**
             * True, if this script is generated as a result of the live edit operation.
             */
            isLiveEdit?: boolean;
            /**
             * URL of source map associated with script (if any).
             */
            sourceMapURL?: string;
            /**
             * True, if this script has sourceURL.
             */
            hasSourceURL?: boolean;
            /**
             * True, if this script is ES6 module.
             */
            isModule?: boolean;
            /**
             * This script length.
             */
            length?: integer;
            /**
             * JavaScript top stack frame of where the script parsed event was triggered if available.
             */
            stackTrace?: Runtime.StackTrace;
            /**
             * If the scriptLanguage is WebAssembly, the code section offset in the module.
             */
            codeOffset?: integer;
            /**
             * The language of the script.
             */
            scriptLanguage?: Debugger.ScriptLanguage;
            /**
             * If the scriptLanguage is WebASsembly, the source of debug symbols for the module.
             */
            debugSymbols?: Debugger.DebugSymbols;
            /**
             * The name the embedder supplied for this script.
             */
            embedderName?: string;
        }
    }

    export namespace HeapProfiler {

        /**
         * Heap snapshot object id.
         */
        export type HeapSnapshotObjectId = string;

        /**
         * Sampling Heap Profile node. Holds callsite information, allocation statistics and child nodes.
         */
        export interface SamplingHeapProfileNode {
            /**
             * Function location.
             */
            callFrame: Runtime.CallFrame;
            /**
             * Allocations size in bytes for the node excluding children.
             */
            selfSize: number;
            /**
             * Node id. Ids are unique across all profiles collected between startSampling and stopSampling.
             */
            id: integer;
            /**
             * Child nodes.
             */
            children: SamplingHeapProfileNode[];
        }

        /**
         * A single sample from a sampling profile.
         */
        export interface SamplingHeapProfileSample {
            /**
             * Allocation size in bytes attributed to the sample.
             */
            size: number;
            /**
             * Id of the corresponding profile tree node.
             */
            nodeId: integer;
            /**
             * Time-ordered sample ordinal number. It is unique across all profiles retrieved
             * between startSampling and stopSampling.
             */
            ordinal: number;
        }

        /**
         * Sampling profile.
         */
        export interface SamplingHeapProfile {
            head: SamplingHeapProfileNode;
            samples: SamplingHeapProfileSample[];
        }

        export interface AddInspectedHeapObjectRequest {
            /**
             * Heap snapshot object id to be accessible by means of $x command line API.
             */
            heapObjectId: HeapSnapshotObjectId;
        }

        export interface GetHeapObjectIdRequest {
            /**
             * Identifier of the object to get heap object id for.
             */
            objectId: Runtime.RemoteObjectId;
        }

        export interface GetHeapObjectIdResponse {
            /**
             * Id of the heap snapshot object corresponding to the passed remote object id.
             */
            heapSnapshotObjectId: HeapSnapshotObjectId;
        }

        export interface GetObjectByHeapObjectIdRequest {
            objectId: HeapSnapshotObjectId;
            /**
             * Symbolic group name that can be used to release multiple objects.
             */
            objectGroup?: string;
        }

        export interface GetObjectByHeapObjectIdResponse {
            /**
             * Evaluation result.
             */
            result: Runtime.RemoteObject;
        }

        export interface GetSamplingProfileResponse {
            /**
             * Return the sampling profile being collected.
             */
            profile: SamplingHeapProfile;
        }

        export interface StartSamplingRequest {
            /**
             * Average sample interval in bytes. Poisson distribution is used for the intervals. The
             * default value is 32768 bytes.
             */
            samplingInterval?: number;
            /**
             * By default, the sampling heap profiler reports only objects which are
             * still alive when the profile is returned via getSamplingProfile or
             * stopSampling, which is useful for determining what functions contribute
             * the most to steady-state memory usage. This flag instructs the sampling
             * heap profiler to also include information about objects discarded by
             * major GC, which will show which functions cause large temporary memory
             * usage or long GC pauses.
             */
            includeObjectsCollectedByMajorGC?: boolean;
            /**
             * By default, the sampling heap profiler reports only objects which are
             * still alive when the profile is returned via getSamplingProfile or
             * stopSampling, which is useful for determining what functions contribute
             * the most to steady-state memory usage. This flag instructs the sampling
             * heap profiler to also include information about objects discarded by
             * minor GC, which is useful when tuning a latency-sensitive application
             * for minimal GC activity.
             */
            includeObjectsCollectedByMinorGC?: boolean;
        }

        export interface StartTrackingHeapObjectsRequest {
            trackAllocations?: boolean;
        }

        export interface StopSamplingResponse {
            /**
             * Recorded sampling heap profile.
             */
            profile: SamplingHeapProfile;
        }

        export interface StopTrackingHeapObjectsRequest {
            /**
             * If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken
             * when the tracking is stopped.
             */
            reportProgress?: boolean;
            /**
             * Deprecated in favor of `exposeInternals`.
             */
            treatGlobalObjectsAsRoots?: boolean;
            /**
             * If true, numerical values are included in the snapshot
             */
            captureNumericValue?: boolean;
            /**
             * If true, exposes internals of the snapshot.
             */
            exposeInternals?: boolean;
        }

        export interface TakeHeapSnapshotRequest {
            /**
             * If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken.
             */
            reportProgress?: boolean;
            /**
             * If true, a raw snapshot without artificial roots will be generated.
             * Deprecated in favor of `exposeInternals`.
             */
            treatGlobalObjectsAsRoots?: boolean;
            /**
             * If true, numerical values are included in the snapshot
             */
            captureNumericValue?: boolean;
            /**
             * If true, exposes internals of the snapshot.
             */
            exposeInternals?: boolean;
        }

        export interface AddHeapSnapshotChunkEvent {
            chunk: string;
        }

        /**
         * If heap objects tracking has been started then backend may send update for one or more fragments
         */
        export interface HeapStatsUpdateEvent {
            /**
             * An array of triplets. Each triplet describes a fragment. The first integer is the fragment
             * index, the second integer is a total count of objects for the fragment, the third integer is
             * a total size of the objects for the fragment.
             */
            statsUpdate: integer[];
        }

        /**
         * If heap objects tracking has been started then backend regularly sends a current value for last
         * seen object id and corresponding timestamp. If the were changes in the heap since last event
         * then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
         */
        export interface LastSeenObjectIdEvent {
            lastSeenObjectId: integer;
            timestamp: number;
        }

        export interface ReportHeapSnapshotProgressEvent {
            done: integer;
            total: integer;
            finished?: boolean;
        }
    }

    export namespace Profiler {

        /**
         * Profile node. Holds callsite information, execution statistics and child nodes.
         */
        export interface ProfileNode {
            /**
             * Unique id of the node.
             */
            id: integer;
            /**
             * Function location.
             */
            callFrame: Runtime.CallFrame;
            /**
             * Number of samples where this node was on top of the call stack.
             */
            hitCount?: integer;
            /**
             * Child node ids.
             */
            children?: integer[];
            /**
             * The reason of being not optimized. The function may be deoptimized or marked as don't
             * optimize.
             */
            deoptReason?: string;
            /**
             * An array of source position ticks.
             */
            positionTicks?: PositionTickInfo[];
        }

        /**
         * Profile.
         */
        export interface Profile {
            /**
             * The list of profile nodes. First item is the root node.
             */
            nodes: ProfileNode[];
            /**
             * Profiling start timestamp in microseconds.
             */
            startTime: number;
            /**
             * Profiling end timestamp in microseconds.
             */
            endTime: number;
            /**
             * Ids of samples top nodes.
             */
            samples?: integer[];
            /**
             * Time intervals between adjacent samples in microseconds. The first delta is relative to the
             * profile startTime.
             */
            timeDeltas?: integer[];
        }

        /**
         * Specifies a number of samples attributed to a certain source position.
         */
        export interface PositionTickInfo {
            /**
             * Source line number (1-based).
             */
            line: integer;
            /**
             * Number of samples attributed to the source line.
             */
            ticks: integer;
        }

        /**
         * Coverage data for a source range.
         */
        export interface CoverageRange {
            /**
             * JavaScript script source offset for the range start.
             */
            startOffset: integer;
            /**
             * JavaScript script source offset for the range end.
             */
            endOffset: integer;
            /**
             * Collected execution count of the source range.
             */
            count: integer;
        }

        /**
         * Coverage data for a JavaScript function.
         */
        export interface FunctionCoverage {
            /**
             * JavaScript function name.
             */
            functionName: string;
            /**
             * Source ranges inside the function with coverage data.
             */
            ranges: CoverageRange[];
            /**
             * Whether coverage data for this function has block granularity.
             */
            isBlockCoverage: boolean;
        }

        /**
         * Coverage data for a JavaScript script.
         */
        export interface ScriptCoverage {
            /**
             * JavaScript script id.
             */
            scriptId: Runtime.ScriptId;
            /**
             * JavaScript script name or url.
             */
            url: string;
            /**
             * Functions contained in the script that has coverage data.
             */
            functions: FunctionCoverage[];
        }

        export interface GetBestEffortCoverageResponse {
            /**
             * Coverage data for the current isolate.
             */
            result: ScriptCoverage[];
        }

        export interface SetSamplingIntervalRequest {
            /**
             * New sampling interval in microseconds.
             */
            interval: integer;
        }

        export interface StartPreciseCoverageRequest {
            /**
             * Collect accurate call counts beyond simple 'covered' or 'not covered'.
             */
            callCount?: boolean;
            /**
             * Collect block-based coverage.
             */
            detailed?: boolean;
            /**
             * Allow the backend to send updates on its own initiative
             */
            allowTriggeredUpdates?: boolean;
        }

        export interface StartPreciseCoverageResponse {
            /**
             * Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
             */
            timestamp: number;
        }

        export interface StopResponse {
            /**
             * Recorded profile.
             */
            profile: Profile;
        }

        export interface TakePreciseCoverageResponse {
            /**
             * Coverage data for the current isolate.
             */
            result: ScriptCoverage[];
            /**
             * Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
             */
            timestamp: number;
        }

        export interface ConsoleProfileFinishedEvent {
            id: string;
            /**
             * Location of console.profileEnd().
             */
            location: Debugger.Location;
            profile: Profile;
            /**
             * Profile title passed as an argument to console.profile().
             */
            title?: string;
        }

        /**
         * Sent when new profile recording is started using console.profile() call.
         */
        export interface ConsoleProfileStartedEvent {
            id: string;
            /**
             * Location of console.profile().
             */
            location: Debugger.Location;
            /**
             * Profile title passed as an argument to console.profile().
             */
            title?: string;
        }

        /**
         * Reports coverage delta since the last poll (either from an event like this, or from
         * `takePreciseCoverage` for the current isolate. May only be sent if precise code
         * coverage has been started. This event can be trigged by the embedder to, for example,
         * trigger collection of coverage data immediately at a certain point in time.
         */
        export interface PreciseCoverageDeltaUpdateEvent {
            /**
             * Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
             */
            timestamp: number;
            /**
             * Identifier for distinguishing coverage events.
             */
            occasion: string;
            /**
             * Coverage data for the current isolate.
             */
            result: ScriptCoverage[];
        }
    }

    /**
     * Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects.
     * Evaluation results are returned as mirror object that expose object type, string representation
     * and unique identifier that can be used for further object reference. Original objects are
     * maintained in memory unless they are either explicitly released or are released along with the
     * other objects in their object group.
     */
    export namespace Runtime {

        /**
         * Unique script identifier.
         */
        export type ScriptId = string;

        export const enum SerializationOptionsSerialization {
            Deep = 'deep',
            Json = 'json',
            IdOnly = 'idOnly',
        }

        /**
         * Represents options for serialization. Overrides `generatePreview` and `returnByValue`.
         */
        export interface SerializationOptions {
            /**
             *  (SerializationOptionsSerialization enum)
             */
            serialization: ('deep' | 'json' | 'idOnly');
            /**
             * Deep serialization depth. Default is full depth. Respected only in `deep` serialization mode.
             */
            maxDepth?: integer;
            /**
             * Embedder-specific parameters. For example if connected to V8 in Chrome these control DOM
             * serialization via `maxNodeDepth: integer` and `includeShadowTree: "none" | "open" | "all"`.
             * Values can be only of type string or integer.
             */
            additionalParameters?: any;
        }

        export const enum DeepSerializedValueType {
            Undefined = 'undefined',
            Null = 'null',
            String = 'string',
            Number = 'number',
            Boolean = 'boolean',
            Bigint = 'bigint',
            Regexp = 'regexp',
            Date = 'date',
            Symbol = 'symbol',
            Array = 'array',
            Object = 'object',
            Function = 'function',
            Map = 'map',
            Set = 'set',
            Weakmap = 'weakmap',
            Weakset = 'weakset',
            Error = 'error',
            Proxy = 'proxy',
            Promise = 'promise',
            Typedarray = 'typedarray',
            Arraybuffer = 'arraybuffer',
            Node = 'node',
            Window = 'window',
            Generator = 'generator',
        }

        /**
         * Represents deep serialized value.
         */
        export interface DeepSerializedValue {
            /**
             *  (DeepSerializedValueType enum)
             */
            type: ('undefined' | 'null' | 'string' | 'number' | 'boolean' | 'bigint' | 'regexp' | 'date' | 'symbol' | 'array' | 'object' | 'function' | 'map' | 'set' | 'weakmap' | 'weakset' | 'error' | 'proxy' | 'promise' | 'typedarray' | 'arraybuffer' | 'node' | 'window' | 'generator');
            value?: any;
            objectId?: string;
            /**
             * Set if value reference met more then once during serialization. In such
             * case, value is provided only to one of the serialized values. Unique
             * per value in the scope of one CDP call.
             */
            weakLocalObjectReference?: integer;
        }

        /**
         * Unique object identifier.
         */
        export type RemoteObjectId = string;

        /**
         * Primitive value which cannot be JSON-stringified. Includes values `-0`, `NaN`, `Infinity`,
         * `-Infinity`, and bigint literals.
         */
        export type UnserializableValue = string;

        export const enum RemoteObjectType {
            Object = 'object',
            Function = 'function',
            Undefined = 'undefined',
            String = 'string',
            Number = 'number',
            Boolean = 'boolean',
            Symbol = 'symbol',
            Bigint = 'bigint',
        }

        export const enum RemoteObjectSubtype {
            Array = 'array',
            Null = 'null',
            Node = 'node',
            Regexp = 'regexp',
            Date = 'date',
            Map = 'map',
            Set = 'set',
            Weakmap = 'weakmap',
            Weakset = 'weakset',
            Iterator = 'iterator',
            Generator = 'generator',
            Error = 'error',
            Proxy = 'proxy',
            Promise = 'promise',
            Typedarray = 'typedarray',
            Arraybuffer = 'arraybuffer',
            Dataview = 'dataview',
            Webassemblymemory = 'webassemblymemory',
            Wasmvalue = 'wasmvalue',
        }

        /**
         * Mirror object referencing original JavaScript object.
         */
        export interface RemoteObject {
            /**
             * Object type. (RemoteObjectType enum)
             */
            type: ('object' | 'function' | 'undefined' | 'string' | 'number' | 'boolean' | 'symbol' | 'bigint');
            /**
             * Object subtype hint. Specified for `object` type values only.
             * NOTE: If you change anything here, make sure to also update
             * `subtype` in `ObjectPreview` and `PropertyPreview` below. (RemoteObjectSubtype enum)
             */
            subtype?: ('array' | 'null' | 'node' | 'regexp' | 'date' | 'map' | 'set' | 'weakmap' | 'weakset' | 'iterator' | 'generator' | 'error' | 'proxy' | 'promise' | 'typedarray' | 'arraybuffer' | 'dataview' | 'webassemblymemory' | 'wasmvalue');
            /**
             * Object class (constructor) name. Specified for `object` type values only.
             */
            className?: string;
            /**
             * Remote object value in case of primitive values or JSON values (if it was requested).
             */
            value?: any;
            /**
             * Primitive value which can not be JSON-stringified does not have `value`, but gets this
             * property.
             */
            unserializableValue?: UnserializableValue;
            /**
             * String representation of the object.
             */
            description?: string;
            /**
             * Deep serialized value.
             */
            deepSerializedValue?: DeepSerializedValue;
            /**
             * Unique object identifier (for non-primitive values).
             */
            objectId?: RemoteObjectId;
            /**
             * Preview containing abbreviated property values. Specified for `object` type values only.
             */
            preview?: ObjectPreview;
            customPreview?: CustomPreview;
        }

        export interface CustomPreview {
            /**
             * The JSON-stringified result of formatter.header(object, config) call.
             * It contains json ML array that represents RemoteObject.
             */
            header: string;
            /**
             * If formatter returns true as a result of formatter.hasBody call then bodyGetterId will
             * contain RemoteObjectId for the function that returns result of formatter.body(object, config) call.
             * The result value is json ML array.
             */
            bodyGetterId?: RemoteObjectId;
        }

        export const enum ObjectPreviewType {
            Object = 'object',
            Function = 'function',
            Undefined = 'undefined',
            String = 'string',
            Number = 'number',
            Boolean = 'boolean',
            Symbol = 'symbol',
            Bigint = 'bigint',
        }

        export const enum ObjectPreviewSubtype {
            Array = 'array',
            Null = 'null',
            Node = 'node',
            Regexp = 'regexp',
            Date = 'date',
            Map = 'map',
            Set = 'set',
            Weakmap = 'weakmap',
            Weakset = 'weakset',
            Iterator = 'iterator',
            Generator = 'generator',
            Error = 'error',
            Proxy = 'proxy',
            Promise = 'promise',
            Typedarray = 'typedarray',
            Arraybuffer = 'arraybuffer',
            Dataview = 'dataview',
            Webassemblymemory = 'webassemblymemory',
            Wasmvalue = 'wasmvalue',
        }

        /**
         * Object containing abbreviated remote object value.
         */
        export interface ObjectPreview {
            /**
             * Object type. (ObjectPreviewType enum)
             */
            type: ('object' | 'function' | 'undefined' | 'string' | 'number' | 'boolean' | 'symbol' | 'bigint');
            /**
             * Object subtype hint. Specified for `object` type values only. (ObjectPreviewSubtype enum)
             */
            subtype?: ('array' | 'null' | 'node' | 'regexp' | 'date' | 'map' | 'set' | 'weakmap' | 'weakset' | 'iterator' | 'generator' | 'error' | 'proxy' | 'promise' | 'typedarray' | 'arraybuffer' | 'dataview' | 'webassemblymemory' | 'wasmvalue');
            /**
             * String representation of the object.
             */
            description?: string;
            /**
             * True iff some of the properties or entries of the original object did not fit.
             */
            overflow: boolean;
            /**
             * List of the properties.
             */
            properties: PropertyPreview[];
            /**
             * List of the entries. Specified for `map` and `set` subtype values only.
             */
            entries?: EntryPreview[];
        }

        export const enum PropertyPreviewType {
            Object = 'object',
            Function = 'function',
            Undefined = 'undefined',
            String = 'string',
            Number = 'number',
            Boolean = 'boolean',
            Symbol = 'symbol',
            Accessor = 'accessor',
            Bigint = 'bigint',
        }

        export const enum PropertyPreviewSubtype {
            Array = 'array',
            Null = 'null',
            Node = 'node',
            Regexp = 'regexp',
            Date = 'date',
            Map = 'map',
            Set = 'set',
            Weakmap = 'weakmap',
            Weakset = 'weakset',
            Iterator = 'iterator',
            Generator = 'generator',
            Error = 'error',
            Proxy = 'proxy',
            Promise = 'promise',
            Typedarray = 'typedarray',
            Arraybuffer = 'arraybuffer',
            Dataview = 'dataview',
            Webassemblymemory = 'webassemblymemory',
            Wasmvalue = 'wasmvalue',
        }

        export interface PropertyPreview {
            /**
             * Property name.
             */
            name: string;
            /**
             * Object type. Accessor means that the property itself is an accessor property. (PropertyPreviewType enum)
             */
            type: ('object' | 'function' | 'undefined' | 'string' | 'number' | 'boolean' | 'symbol' | 'accessor' | 'bigint');
            /**
             * User-friendly property value string.
             */
            value?: string;
            /**
             * Nested value preview.
             */
            valuePreview?: ObjectPreview;
            /**
             * Object subtype hint. Specified for `object` type values only. (PropertyPreviewSubtype enum)
             */
            subtype?: ('array' | 'null' | 'node' | 'regexp' | 'date' | 'map' | 'set' | 'weakmap' | 'weakset' | 'iterator' | 'generator' | 'error' | 'proxy' | 'promise' | 'typedarray' | 'arraybuffer' | 'dataview' | 'webassemblymemory' | 'wasmvalue');
        }

        export interface EntryPreview {
            /**
             * Preview of the key. Specified for map-like collection entries.
             */
            key?: ObjectPreview;
            /**
             * Preview of the value.
             */
            value: ObjectPreview;
        }

        /**
         * Object property descriptor.
         */
        export interface PropertyDescriptor {
            /**
             * Property name or symbol description.
             */
            name: string;
            /**
             * The value associated with the property.
             */
            value?: RemoteObject;
            /**
             * True if the value associated with the property may be changed (data descriptors only).
             */
            writable?: boolean;
            /**
             * A function which serves as a getter for the property, or `undefined` if there is no getter
             * (accessor descriptors only).
             */
            get?: RemoteObject;
            /**
             * A function which serves as a setter for the property, or `undefined` if there is no setter
             * (accessor descriptors only).
             */
            set?: RemoteObject;
            /**
             * True if the type of this property descriptor may be changed and if the property may be
             * deleted from the corresponding object.
             */
            configurable: boolean;
            /**
             * True if this property shows up during enumeration of the properties on the corresponding
             * object.
             */
            enumerable: boolean;
            /**
             * True if the result was thrown during the evaluation.
             */
            wasThrown?: boolean;
            /**
             * True if the property is owned for the object.
             */
            isOwn?: boolean;
            /**
             * Property symbol object, if the property is of the `symbol` type.
             */
            symbol?: RemoteObject;
        }

        /**
         * Object internal property descriptor. This property isn't normally visible in JavaScript code.
         */
        export interface InternalPropertyDescriptor {
            /**
             * Conventional property name.
             */
            name: string;
            /**
             * The value associated with the property.
             */
            value?: RemoteObject;
        }

        /**
         * Object private field descriptor.
         */
        export interface PrivatePropertyDescriptor {
            /**
             * Private property name.
             */
            name: string;
            /**
             * The value associated with the private property.
             */
            value?: RemoteObject;
            /**
             * A function which serves as a getter for the private property,
             * or `undefined` if there is no getter (accessor descriptors only).
             */
            get?: RemoteObject;
            /**
             * A function which serves as a setter for the private property,
             * or `undefined` if there is no setter (accessor descriptors only).
             */
            set?: RemoteObject;
        }

        /**
         * Represents function call argument. Either remote object id `objectId`, primitive `value`,
         * unserializable primitive value or neither of (for undefined) them should be specified.
         */
        export interface CallArgument {
            /**
             * Primitive value or serializable javascript object.
             */
            value?: any;
            /**
             * Primitive value which can not be JSON-stringified.
             */
            unserializableValue?: UnserializableValue;
            /**
             * Remote object handle.
             */
            objectId?: RemoteObjectId;
        }

        /**
         * Id of an execution context.
         */
        export type ExecutionContextId = integer;

        /**
         * Description of an isolated world.
         */
        export interface ExecutionContextDescription {
            /**
             * Unique id of the execution context. It can be used to specify in which execution context
             * script evaluation should be performed.
             */
            id: ExecutionContextId;
            /**
             * Execution context origin.
             */
            origin: string;
            /**
             * Human readable name describing given context.
             */
            name: string;
            /**
             * A system-unique execution context identifier. Unlike the id, this is unique across
             * multiple processes, so can be reliably used to identify specific context while backend
             * performs a cross-process navigation.
             */
            uniqueId: string;
            /**
             * Embedder-specific auxiliary data likely matching {isDefault: boolean, type: 'default'|'isolated'|'worker', frameId: string}
             */
            auxData?: any;
        }

        /**
         * Detailed information about exception (or error) that was thrown during script compilation or
         * execution.
         */
        export interface ExceptionDetails {
            /**
             * Exception id.
             */
            exceptionId: integer;
            /**
             * Exception text, which should be used together with exception object when available.
             */
            text: string;
            /**
             * Line number of the exception location (0-based).
             */
            lineNumber: integer;
            /**
             * Column number of the exception location (0-based).
             */
            columnNumber: integer;
            /**
             * Script ID of the exception location.
             */
            scriptId?: ScriptId;
            /**
             * URL of the exception location, to be used when the script was not reported.
             */
            url?: string;
            /**
             * JavaScript stack trace if available.
             */
            stackTrace?: StackTrace;
            /**
             * Exception object if available.
             */
            exception?: RemoteObject;
            /**
             * Identifier of the context where exception happened.
             */
            executionContextId?: ExecutionContextId;
            /**
             * Dictionary with entries of meta data that the client associated
             * with this exception, such as information about associated network
             * requests, etc.
             */
            exceptionMetaData?: any;
        }

        /**
         * Number of milliseconds since epoch.
         */
        export type Timestamp = number;

        /**
         * Number of milliseconds.
         */
        export type TimeDelta = number;

        /**
         * Stack entry for runtime errors and assertions.
         */
        export interface CallFrame {
            /**
             * JavaScript function name.
             */
            functionName: string;
            /**
             * JavaScript script id.
             */
            scriptId: ScriptId;
            /**
             * JavaScript script name or url.
             */
            url: string;
            /**
             * JavaScript script line number (0-based).
             */
            lineNumber: integer;
            /**
             * JavaScript script column number (0-based).
             */
            columnNumber: integer;
        }

        /**
         * Call frames for assertions or error messages.
         */
        export interface StackTrace {
            /**
             * String label of this stack trace. For async traces this may be a name of the function that
             * initiated the async call.
             */
            description?: string;
            /**
             * JavaScript function name.
             */
            callFrames: CallFrame[];
            /**
             * Asynchronous JavaScript stack trace that preceded this stack, if available.
             */
            parent?: StackTrace;
            /**
             * Asynchronous JavaScript stack trace that preceded this stack, if available.
             */
            parentId?: StackTraceId;
        }

        /**
         * Unique identifier of current debugger.
         */
        export type UniqueDebuggerId = string;

        /**
         * If `debuggerId` is set stack trace comes from another debugger and can be resolved there. This
         * allows to track cross-debugger calls. See `Runtime.StackTrace` and `Debugger.paused` for usages.
         */
        export interface StackTraceId {
            id: string;
            debuggerId?: UniqueDebuggerId;
        }

        export interface AwaitPromiseRequest {
            /**
             * Identifier of the promise.
             */
            promiseObjectId: RemoteObjectId;
            /**
             * Whether the result is expected to be a JSON object that should be sent by value.
             */
            returnByValue?: boolean;
            /**
             * Whether preview should be generated for the result.
             */
            generatePreview?: boolean;
        }

        export interface AwaitPromiseResponse {
            /**
             * Promise result. Will contain rejected value if promise was rejected.
             */
            result: RemoteObject;
            /**
             * Exception details if stack strace is available.
             */
            exceptionDetails?: ExceptionDetails;
        }

        export interface CallFunctionOnRequest {
            /**
             * Declaration of the function to call.
             */
            functionDeclaration: string;
            /**
             * Identifier of the object to call function on. Either objectId or executionContextId should
             * be specified.
             */
            objectId?: RemoteObjectId;
            /**
             * Call arguments. All call arguments must belong to the same JavaScript world as the target
             * object.
             */
            arguments?: CallArgument[];
            /**
             * In silent mode exceptions thrown during evaluation are not reported and do not pause
             * execution. Overrides `setPauseOnException` state.
             */
            silent?: boolean;
            /**
             * Whether the result is expected to be a JSON object which should be sent by value.
             * Can be overriden by `serializationOptions`.
             */
            returnByValue?: boolean;
            /**
             * Whether preview should be generated for the result.
             */
            generatePreview?: boolean;
            /**
             * Whether execution should be treated as initiated by user in the UI.
             */
            userGesture?: boolean;
            /**
             * Whether execution should `await` for resulting value and return once awaited promise is
             * resolved.
             */
            awaitPromise?: boolean;
            /**
             * Specifies execution context which global object will be used to call function on. Either
             * executionContextId or objectId should be specified.
             */
            executionContextId?: ExecutionContextId;
            /**
             * Symbolic group name that can be used to release multiple objects. If objectGroup is not
             * specified and objectId is, objectGroup will be inherited from object.
             */
            objectGroup?: string;
            /**
             * Whether to throw an exception if side effect cannot be ruled out during evaluation.
             */
            throwOnSideEffect?: boolean;
            /**
             * An alternative way to specify the execution context to call function on.
             * Compared to contextId that may be reused across processes, this is guaranteed to be
             * system-unique, so it can be used to prevent accidental function call
             * in context different than intended (e.g. as a result of navigation across process
             * boundaries).
             * This is mutually exclusive with `executionContextId`.
             */
            uniqueContextId?: string;
            /**
             * Specifies the result serialization. If provided, overrides
             * `generatePreview` and `returnByValue`.
             */
            serializationOptions?: SerializationOptions;
        }

        export interface CallFunctionOnResponse {
            /**
             * Call result.
             */
            result: RemoteObject;
            /**
             * Exception details.
             */
            exceptionDetails?: ExceptionDetails;
        }

        export interface CompileScriptRequest {
            /**
             * Expression to compile.
             */
            expression: string;
            /**
             * Source url to be set for the script.
             */
            sourceURL: string;
            /**
             * Specifies whether the compiled script should be persisted.
             */
            persistScript: boolean;
            /**
             * Specifies in which execution context to perform script run. If the parameter is omitted the
             * evaluation will be performed in the context of the inspected page.
             */
            executionContextId?: ExecutionContextId;
        }

        export interface CompileScriptResponse {
            /**
             * Id of the script.
             */
            scriptId?: ScriptId;
            /**
             * Exception details.
             */
            exceptionDetails?: ExceptionDetails;
        }

        export interface EvaluateRequest {
            /**
             * Expression to evaluate.
             */
            expression: string;
            /**
             * Symbolic group name that can be used to release multiple objects.
             */
            objectGroup?: string;
            /**
             * Determines whether Command Line API should be available during the evaluation.
             */
            includeCommandLineAPI?: boolean;
            /**
             * In silent mode exceptions thrown during evaluation are not reported and do not pause
             * execution. Overrides `setPauseOnException` state.
             */
            silent?: boolean;
            /**
             * Specifies in which execution context to perform evaluation. If the parameter is omitted the
             * evaluation will be performed in the context of the inspected page.
             * This is mutually exclusive with `uniqueContextId`, which offers an
             * alternative way to identify the execution context that is more reliable
             * in a multi-process environment.
             */
            contextId?: ExecutionContextId;
            /**
             * Whether the result is expected to be a JSON object that should be sent by value.
             */
            returnByValue?: boolean;
            /**
             * Whether preview should be generated for the result.
             */
            generatePreview?: boolean;
            /**
             * Whether execution should be treated as initiated by user in the UI.
             */
            userGesture?: boolean;
            /**
             * Whether execution should `await` for resulting value and return once awaited promise is
             * resolved.
             */
            awaitPromise?: boolean;
            /**
             * Whether to throw an exception if side effect cannot be ruled out during evaluation.
             * This implies `disableBreaks` below.
             */
            throwOnSideEffect?: boolean;
            /**
             * Terminate execution after timing out (number of milliseconds).
             */
            timeout?: TimeDelta;
            /**
             * Disable breakpoints during execution.
             */
            disableBreaks?: boolean;
            /**
             * Setting this flag to true enables `let` re-declaration and top-level `await`.
             * Note that `let` variables can only be re-declared if they originate from
             * `replMode` themselves.
             */
            replMode?: boolean;
            /**
             * The Content Security Policy (CSP) for the target might block 'unsafe-eval'
             * which includes eval(), Function(), setTimeout() and setInterval()
             * when called with non-callable arguments. This flag bypasses CSP for this
             * evaluation and allows unsafe-eval. Defaults to true.
             */
            allowUnsafeEvalBlockedByCSP?: boolean;
            /**
             * An alternative way to specify the execution context to evaluate in.
             * Compared to contextId that may be reused across processes, this is guaranteed to be
             * system-unique, so it can be used to prevent accidental evaluation of the expression
             * in context different than intended (e.g. as a result of navigation across process
             * boundaries).
             * This is mutually exclusive with `contextId`.
             */
            uniqueContextId?: string;
            /**
             * Specifies the result serialization. If provided, overrides
             * `generatePreview` and `returnByValue`.
             */
            serializationOptions?: SerializationOptions;
        }

        export interface EvaluateResponse {
            /**
             * Evaluation result.
             */
            result: RemoteObject;
            /**
             * Exception details.
             */
            exceptionDetails?: ExceptionDetails;
        }

        export interface GetIsolateIdResponse {
            /**
             * The isolate id.
             */
            id: string;
        }

        export interface GetHeapUsageResponse {
            /**
             * Used heap size in bytes.
             */
            usedSize: number;
            /**
             * Allocated heap size in bytes.
             */
            totalSize: number;
        }

        export interface GetPropertiesRequest {
            /**
             * Identifier of the object to return properties for.
             */
            objectId: RemoteObjectId;
            /**
             * If true, returns properties belonging only to the element itself, not to its prototype
             * chain.
             */
            ownProperties?: boolean;
            /**
             * If true, returns accessor properties (with getter/setter) only; internal properties are not
             * returned either.
             */
            accessorPropertiesOnly?: boolean;
            /**
             * Whether preview should be generated for the results.
             */
            generatePreview?: boolean;
            /**
             * If true, returns non-indexed properties only.
             */
            nonIndexedPropertiesOnly?: boolean;
        }

        export interface GetPropertiesResponse {
            /**
             * Object properties.
             */
            result: PropertyDescriptor[];
            /**
             * Internal object properties (only of the element itself).
             */
            internalProperties?: InternalPropertyDescriptor[];
            /**
             * Object private properties.
             */
            privateProperties?: PrivatePropertyDescriptor[];
            /**
             * Exception details.
             */
            exceptionDetails?: ExceptionDetails;
        }

        export interface GlobalLexicalScopeNamesRequest {
            /**
             * Specifies in which execution context to lookup global scope variables.
             */
            executionContextId?: ExecutionContextId;
        }

        export interface GlobalLexicalScopeNamesResponse {
            names: string[];
        }

        export interface QueryObjectsRequest {
            /**
             * Identifier of the prototype to return objects for.
             */
            prototypeObjectId: RemoteObjectId;
            /**
             * Symbolic group name that can be used to release the results.
             */
            objectGroup?: string;
        }

        export interface QueryObjectsResponse {
            /**
             * Array with objects.
             */
            objects: RemoteObject;
        }

        export interface ReleaseObjectRequest {
            /**
             * Identifier of the object to release.
             */
            objectId: RemoteObjectId;
        }

        export interface ReleaseObjectGroupRequest {
            /**
             * Symbolic object group name.
             */
            objectGroup: string;
        }

        export interface RunScriptRequest {
            /**
             * Id of the script to run.
             */
            scriptId: ScriptId;
            /**
             * Specifies in which execution context to perform script run. If the parameter is omitted the
             * evaluation will be performed in the context of the inspected page.
             */
            executionContextId?: ExecutionContextId;
            /**
             * Symbolic group name that can be used to release multiple objects.
             */
            objectGroup?: string;
            /**
             * In silent mode exceptions thrown during evaluation are not reported and do not pause
             * execution. Overrides `setPauseOnException` state.
             */
            silent?: boolean;
            /**
             * Determines whether Command Line API should be available during the evaluation.
             */
            includeCommandLineAPI?: boolean;
            /**
             * Whether the result is expected to be a JSON object which should be sent by value.
             */
            returnByValue?: boolean;
            /**
             * Whether preview should be generated for the result.
             */
            generatePreview?: boolean;
            /**
             * Whether execution should `await` for resulting value and return once awaited promise is
             * resolved.
             */
            awaitPromise?: boolean;
        }

        export interface RunScriptResponse {
            /**
             * Run result.
             */
            result: RemoteObject;
            /**
             * Exception details.
             */
            exceptionDetails?: ExceptionDetails;
        }

        export interface SetAsyncCallStackDepthRequest {
            /**
             * Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async
             * call stacks (default).
             */
            maxDepth: integer;
        }

        export interface SetCustomObjectFormatterEnabledRequest {
            enabled: boolean;
        }

        export interface SetMaxCallStackSizeToCaptureRequest {
            size: integer;
        }

        export interface AddBindingRequest {
            name: string;
            /**
             * If specified, the binding would only be exposed to the specified
             * execution context. If omitted and `executionContextName` is not set,
             * the binding is exposed to all execution contexts of the target.
             * This parameter is mutually exclusive with `executionContextName`.
             * Deprecated in favor of `executionContextName` due to an unclear use case
             * and bugs in implementation (crbug.com/1169639). `executionContextId` will be
             * removed in the future.
             */
            executionContextId?: ExecutionContextId;
            /**
             * If specified, the binding is exposed to the executionContext with
             * matching name, even for contexts created after the binding is added.
             * See also `ExecutionContext.name` and `worldName` parameter to
             * `Page.addScriptToEvaluateOnNewDocument`.
             * This parameter is mutually exclusive with `executionContextId`.
             */
            executionContextName?: string;
        }

        export interface RemoveBindingRequest {
            name: string;
        }

        export interface GetExceptionDetailsRequest {
            /**
             * The error object for which to resolve the exception details.
             */
            errorObjectId: RemoteObjectId;
        }

        export interface GetExceptionDetailsResponse {
            exceptionDetails?: ExceptionDetails;
        }

        /**
         * Notification is issued every time when binding is called.
         */
        export interface BindingCalledEvent {
            name: string;
            payload: string;
            /**
             * Identifier of the context where the call was made.
             */
            executionContextId: ExecutionContextId;
        }

        export const enum ConsoleAPICalledEventType {
            Log = 'log',
            Debug = 'debug',
            Info = 'info',
            Error = 'error',
            Warning = 'warning',
            Dir = 'dir',
            DirXML = 'dirxml',
            Table = 'table',
            Trace = 'trace',
            Clear = 'clear',
            StartGroup = 'startGroup',
            StartGroupCollapsed = 'startGroupCollapsed',
            EndGroup = 'endGroup',
            Assert = 'assert',
            Profile = 'profile',
            ProfileEnd = 'profileEnd',
            Count = 'count',
            TimeEnd = 'timeEnd',
        }

        /**
         * Issued when console API was called.
         */
        export interface ConsoleAPICalledEvent {
            /**
             * Type of the call. (ConsoleAPICalledEventType enum)
             */
            type: ('log' | 'debug' | 'info' | 'error' | 'warning' | 'dir' | 'dirxml' | 'table' | 'trace' | 'clear' | 'startGroup' | 'startGroupCollapsed' | 'endGroup' | 'assert' | 'profile' | 'profileEnd' | 'count' | 'timeEnd');
            /**
             * Call arguments.
             */
            args: RemoteObject[];
            /**
             * Identifier of the context where the call was made.
             */
            executionContextId: ExecutionContextId;
            /**
             * Call timestamp.
             */
            timestamp: Timestamp;
            /**
             * Stack trace captured when the call was made. The async stack chain is automatically reported for
             * the following call types: `assert`, `error`, `trace`, `warning`. For other types the async call
             * chain can be retrieved using `Debugger.getStackTrace` and `stackTrace.parentId` field.
             */
            stackTrace?: StackTrace;
            /**
             * Console context descriptor for calls on non-default console context (not console.*):
             * 'anonymous#unique-logger-id' for call on unnamed context, 'name#unique-logger-id' for call
             * on named context.
             */
            context?: string;
        }

        /**
         * Issued when unhandled exception was revoked.
         */
        export interface ExceptionRevokedEvent {
            /**
             * Reason describing why exception was revoked.
             */
            reason: string;
            /**
             * The id of revoked exception, as reported in `exceptionThrown`.
             */
            exceptionId: integer;
        }

        /**
         * Issued when exception was thrown and unhandled.
         */
        export interface ExceptionThrownEvent {
            /**
             * Timestamp of the exception.
             */
            timestamp: Timestamp;
            exceptionDetails: ExceptionDetails;
        }

        /**
         * Issued when new execution context is created.
         */
        export interface ExecutionContextCreatedEvent {
            /**
             * A newly created execution context.
             */
            context: ExecutionContextDescription;
        }

        /**
         * Issued when execution context is destroyed.
         */
        export interface ExecutionContextDestroyedEvent {
            /**
             * Id of the destroyed context
             */
            executionContextId: ExecutionContextId;
            /**
             * Unique Id of the destroyed context
             */
            executionContextUniqueId: string;
        }

        /**
         * Issued when object should be inspected (for example, as a result of inspect() command line API
         * call).
         */
        export interface InspectRequestedEvent {
            object: RemoteObject;
            hints: any;
            /**
             * Identifier of the context where the call was made.
             */
            executionContextId?: ExecutionContextId;
        }
    }

    /**
     * This domain is deprecated.
     */
    export namespace Schema {

        /**
         * Description of the protocol domain.
         */
        export interface Domain {
            /**
             * Domain name.
             */
            name: string;
            /**
             * Domain version.
             */
            version: string;
        }

        export interface GetDomainsResponse {
            /**
             * List of supported domains.
             */
            domains: Domain[];
        }
    }

    export namespace Accessibility {

        /**
         * Unique accessibility node identifier.
         */
        export type AXNodeId = string;

        /**
         * Enum of possible property types.
         */
        export type AXValueType = ('boolean' | 'tristate' | 'booleanOrUndefined' | 'idref' | 'idrefList' | 'integer' | 'node' | 'nodeList' | 'number' | 'string' | 'computedString' | 'token' | 'tokenList' | 'domRelation' | 'role' | 'internalRole' | 'valueUndefined');

        /**
         * Enum of possible property sources.
         */
        export type AXValueSourceType = ('attribute' | 'implicit' | 'style' | 'contents' | 'placeholder' | 'relatedElement');

        /**
         * Enum of possible native property sources (as a subtype of a particular AXValueSourceType).
         */
        export type AXValueNativeSourceType = ('description' | 'figcaption' | 'label' | 'labelfor' | 'labelwrapped' | 'legend' | 'rubyannotation' | 'tablecaption' | 'title' | 'other');

        /**
         * A single source for a computed AX property.
         */
        export interface AXValueSource {
            /**
             * What type of source this is.
             */
            type: AXValueSourceType;
            /**
             * The value of this property source.
             */
            value?: AXValue;
            /**
             * The name of the relevant attribute, if any.
             */
            attribute?: string;
            /**
             * The value of the relevant attribute, if any.
             */
            attributeValue?: AXValue;
            /**
             * Whether this source is superseded by a higher priority source.
             */
            superseded?: boolean;
            /**
             * The native markup source for this value, e.g. a `<label>` element.
             */
            nativeSource?: AXValueNativeSourceType;
            /**
             * The value, such as a node or node list, of the native source.
             */
            nativeSourceValue?: AXValue;
            /**
             * Whether the value for this property is invalid.
             */
            invalid?: boolean;
            /**
             * Reason for the value being invalid, if it is.
             */
            invalidReason?: string;
        }

        export interface AXRelatedNode {
            /**
             * The BackendNodeId of the related DOM node.
             */
            backendDOMNodeId: DOM.BackendNodeId;
            /**
             * The IDRef value provided, if any.
             */
            idref?: string;
            /**
             * The text alternative of this node in the current context.
             */
            text?: string;
        }

        export interface AXProperty {
            /**
             * The name of this property.
             */
            name: AXPropertyName;
            /**
             * The value of this property.
             */
            value: AXValue;
        }

        /**
         * A single computed AX property.
         */
        export interface AXValue {
            /**
             * The type of this value.
             */
            type: AXValueType;
            /**
             * The computed value of this property.
             */
            value?: any;
            /**
             * One or more related nodes, if applicable.
             */
            relatedNodes?: AXRelatedNode[];
            /**
             * The sources which contributed to the computation of this property.
             */
            sources?: AXValueSource[];
        }

        /**
         * Values of AXProperty name:
         * - from 'busy' to 'roledescription': states which apply to every AX node
         * - from 'live' to 'root': attributes which apply to nodes in live regions
         * - from 'autocomplete' to 'valuetext': attributes which apply to widgets
         * - from 'checked' to 'selected': states which apply to widgets
         * - from 'activedescendant' to 'owns' - relationships between elements other than parent/child/sibling.
         */
        export type AXPropertyName = ('busy' | 'disabled' | 'editable' | 'focusable' | 'focused' | 'hidden' | 'hiddenRoot' | 'invalid' | 'keyshortcuts' | 'settable' | 'roledescription' | 'live' | 'atomic' | 'relevant' | 'root' | 'autocomplete' | 'hasPopup' | 'level' | 'multiselectable' | 'orientation' | 'multiline' | 'readonly' | 'required' | 'valuemin' | 'valuemax' | 'valuetext' | 'checked' | 'expanded' | 'modal' | 'pressed' | 'selected' | 'activedescendant' | 'controls' | 'describedby' | 'details' | 'errormessage' | 'flowto' | 'labelledby' | 'owns');

        /**
         * A node in the accessibility tree.
         */
        export interface AXNode {
            /**
             * Unique identifier for this node.
             */
            nodeId: AXNodeId;
            /**
             * Whether this node is ignored for accessibility
             */
            ignored: boolean;
            /**
             * Collection of reasons why this node is hidden.
             */
            ignoredReasons?: AXProperty[];
            /**
             * This `Node`'s role, whether explicit or implicit.
             */
            role?: AXValue;
            /**
             * This `Node`'s Chrome raw role.
             */
            chromeRole?: AXValue;
            /**
             * The accessible name for this `Node`.
             */
            name?: AXValue;
            /**
             * The accessible description for this `Node`.
             */
            description?: AXValue;
            /**
             * The value for this `Node`.
             */
            value?: AXValue;
            /**
             * All other properties
             */
            properties?: AXProperty[];
            /**
             * ID for this node's parent.
             */
            parentId?: AXNodeId;
            /**
             * IDs for each of this node's child nodes.
             */
            childIds?: AXNodeId[];
            /**
             * The backend ID for the associated DOM node, if any.
             */
            backendDOMNodeId?: DOM.BackendNodeId;
            /**
             * The frame ID for the frame associated with this nodes document.
             */
            frameId?: Page.FrameId;
        }

        export interface GetPartialAXTreeRequest {
            /**
             * Identifier of the node to get the partial accessibility tree for.
             */
            nodeId?: DOM.NodeId;
            /**
             * Identifier of the backend node to get the partial accessibility tree for.
             */
            backendNodeId?: DOM.BackendNodeId;
            /**
             * JavaScript object id of the node wrapper to get the partial accessibility tree for.
             */
            objectId?: Runtime.RemoteObjectId;
            /**
             * Whether to fetch this node's ancestors, siblings and children. Defaults to true.
             */
            fetchRelatives?: boolean;
        }

        export interface GetPartialAXTreeResponse {
            /**
             * The `Accessibility.AXNode` for this DOM node, if it exists, plus its ancestors, siblings and
             * children, if requested.
             */
            nodes: AXNode[];
        }

        export interface GetFullAXTreeRequest {
            /**
             * The maximum depth at which descendants of the root node should be retrieved.
             * If omitted, the full tree is returned.
             */
            depth?: integer;
            /**
             * The frame for whose document the AX tree should be retrieved.
             * If omitted, the root frame is used.
             */
            frameId?: Page.FrameId;
        }

        export interface GetFullAXTreeResponse {
            nodes: AXNode[];
        }

        export interface GetRootAXNodeRequest {
            /**
             * The frame in whose document the node resides.
             * If omitted, the root frame is used.
             */
            frameId?: Page.FrameId;
        }

        export interface GetRootAXNodeResponse {
            node: AXNode;
        }

        export interface GetAXNodeAndAncestorsRequest {
            /**
             * Identifier of the node to get.
             */
            nodeId?: DOM.NodeId;
            /**
             * Identifier of the backend node to get.
             */
            backendNodeId?: DOM.BackendNodeId;
            /**
             * JavaScript object id of the node wrapper to get.
             */
            objectId?: Runtime.RemoteObjectId;
        }

        export interface GetAXNodeAndAncestorsResponse {
            nodes: AXNode[];
        }

        export interface GetChildAXNodesRequest {
            id: AXNodeId;
            /**
             * The frame in whose document the node resides.
             * If omitted, the root frame is used.
             */
            frameId?: Page.FrameId;
        }

        export interface GetChildAXNodesResponse {
            nodes: AXNode[];
        }

        export interface QueryAXTreeRequest {
            /**
             * Identifier of the node for the root to query.
             */
            nodeId?: DOM.NodeId;
            /**
             * Identifier of the backend node for the root to query.
             */
            backendNodeId?: DOM.BackendNodeId;
            /**
             * JavaScript object id of the node wrapper for the root to query.
             */
            objectId?: Runtime.RemoteObjectId;
            /**
             * Find nodes with this computed name.
             */
            accessibleName?: string;
            /**
             * Find nodes with this computed role.
             */
            role?: string;
        }

        export interface QueryAXTreeResponse {
            /**
             * A list of `Accessibility.AXNode` matching the specified attributes,
             * including nodes that are ignored for accessibility.
             */
            nodes: AXNode[];
        }

        /**
         * The loadComplete event mirrors the load complete event sent by the browser to assistive
         * technology when the web page has finished loading.
         */
        export interface LoadCompleteEvent {
            /**
             * New document root node.
             */
            root: AXNode;
        }

        /**
         * The nodesUpdated event is sent every time a previously requested node has changed the in tree.
         */
        export interface NodesUpdatedEvent {
            /**
             * Updated node data.
             */
            nodes: AXNode[];
        }
    }

    export namespace Animation {

        export const enum AnimationType {
            CSSTransition = 'CSSTransition',
            CSSAnimation = 'CSSAnimation',
            WebAnimation = 'WebAnimation',
        }

        /**
         * Animation instance.
         */
        export interface Animation {
            /**
             * `Animation`'s id.
             */
            id: string;
            /**
             * `Animation`'s name.
             */
            name: string;
            /**
             * `Animation`'s internal paused state.
             */
            pausedState: boolean;
            /**
             * `Animation`'s play state.
             */
            playState: string;
            /**
             * `Animation`'s playback rate.
             */
            playbackRate: number;
            /**
             * `Animation`'s start time.
             * Milliseconds for time based animations and
             * percentage [0 - 100] for scroll driven animations
             * (i.e. when viewOrScrollTimeline exists).
             */
            startTime: number;
            /**
             * `Animation`'s current time.
             */
            currentTime: number;
            /**
             * Animation type of `Animation`. (AnimationType enum)
             */
            type: ('CSSTransition' | 'CSSAnimation' | 'WebAnimation');
            /**
             * `Animation`'s source animation node.
             */
            source?: AnimationEffect;
            /**
             * A unique ID for `Animation` representing the sources that triggered this CSS
             * animation/transition.
             */
            cssId?: string;
            /**
             * View or scroll timeline
             */
            viewOrScrollTimeline?: ViewOrScrollTimeline;
        }

        /**
         * Timeline instance
         */
        export interface ViewOrScrollTimeline {
            /**
             * Scroll container node
             */
            sourceNodeId?: DOM.BackendNodeId;
            /**
             * Represents the starting scroll position of the timeline
             * as a length offset in pixels from scroll origin.
             */
            startOffset?: number;
            /**
             * Represents the ending scroll position of the timeline
             * as a length offset in pixels from scroll origin.
             */
            endOffset?: number;
            /**
             * The element whose principal box's visibility in the
             * scrollport defined the progress of the timeline.
             * Does not exist for animations with ScrollTimeline
             */
            subjectNodeId?: DOM.BackendNodeId;
            /**
             * Orientation of the scroll
             */
            axis: DOM.ScrollOrientation;
        }

        /**
         * AnimationEffect instance
         */
        export interface AnimationEffect {
            /**
             * `AnimationEffect`'s delay.
             */
            delay: number;
            /**
             * `AnimationEffect`'s end delay.
             */
            endDelay: number;
            /**
             * `AnimationEffect`'s iteration start.
             */
            iterationStart: number;
            /**
             * `AnimationEffect`'s iterations.
             */
            iterations: number;
            /**
             * `AnimationEffect`'s iteration duration.
             * Milliseconds for time based animations and
             * percentage [0 - 100] for scroll driven animations
             * (i.e. when viewOrScrollTimeline exists).
             */
            duration: number;
            /**
             * `AnimationEffect`'s playback direction.
             */
            direction: string;
            /**
             * `AnimationEffect`'s fill mode.
             */
            fill: string;
            /**
             * `AnimationEffect`'s target node.
             */
            backendNodeId?: DOM.BackendNodeId;
            /**
             * `AnimationEffect`'s keyframes.
             */
            keyframesRule?: KeyframesRule;
            /**
             * `AnimationEffect`'s timing function.
             */
            easing: string;
        }

        /**
         * Keyframes Rule
         */
        export interface KeyframesRule {
            /**
             * CSS keyframed animation's name.
             */
            name?: string;
            /**
             * List of animation keyframes.
             */
            keyframes: KeyframeStyle[];
        }

        /**
         * Keyframe Style
         */
        export interface KeyframeStyle {
            /**
             * Keyframe's time offset.
             */
            offset: string;
            /**
             * `AnimationEffect`'s timing function.
             */
            easing: string;
        }

        export interface GetCurrentTimeRequest {
            /**
             * Id of animation.
             */
            id: string;
        }

        export interface GetCurrentTimeResponse {
            /**
             * Current time of the page.
             */
            currentTime: number;
        }

        export interface GetPlaybackRateResponse {
            /**
             * Playback rate for animations on page.
             */
            playbackRate: number;
        }

        export interface ReleaseAnimationsRequest {
            /**
             * List of animation ids to seek.
             */
            animations: string[];
        }

        export interface ResolveAnimationRequest {
            /**
             * Animation id.
             */
            animationId: string;
        }

        export interface ResolveAnimationResponse {
            /**
             * Corresponding remote object.
             */
            remoteObject: Runtime.RemoteObject;
        }

        export interface SeekAnimationsRequest {
            /**
             * List of animation ids to seek.
             */
            animations: string[];
            /**
             * Set the current time of each animation.
             */
            currentTime: number;
        }

        export interface SetPausedRequest {
            /**
             * Animations to set the pause state of.
             */
            animations: string[];
            /**
             * Paused state to set to.
             */
            paused: boolean;
        }

        export interface SetPlaybackRateRequest {
            /**
             * Playback rate for animations on page
             */
            playbackRate: number;
        }

        export interface SetTimingRequest {
            /**
             * Animation id.
             */
            animationId: string;
            /**
             * Duration of the animation.
             */
            duration: number;
            /**
             * Delay of the animation.
             */
            delay: number;
        }

        /**
         * Event for when an animation has been cancelled.
         */
        export interface AnimationCanceledEvent {
            /**
             * Id of the animation that was cancelled.
             */
            id: string;
        }

        /**
         * Event for each animation that has been created.
         */
        export interface AnimationCreatedEvent {
            /**
             * Id of the animation that was created.
             */
            id: string;
        }

        /**
         * Event for animation that has been started.
         */
        export interface AnimationStartedEvent {
            /**
             * Animation that was started.
             */
            animation: Animation;
        }

        /**
         * Event for animation that has been updated.
         */
        export interface AnimationUpdatedEvent {
            /**
             * Animation that was updated.
             */
            animation: Animation;
        }
    }

    /**
     * Audits domain allows investigation of page violations and possible improvements.
     */
    export namespace Audits {

        /**
         * Information about a cookie that is affected by an inspector issue.
         */
        export interface AffectedCookie {
            /**
             * The following three properties uniquely identify a cookie
             */
            name: string;
            path: string;
            domain: string;
        }

        /**
         * Information about a request that is affected by an inspector issue.
         */
        export interface AffectedRequest {
            /**
             * The unique request id.
             */
            requestId: Network.RequestId;
            url?: string;
        }

        /**
         * Information about the frame affected by an inspector issue.
         */
        export interface AffectedFrame {
            frameId: Page.FrameId;
        }

        export type CookieExclusionReason = ('ExcludeSameSiteUnspecifiedTreatedAsLax' | 'ExcludeSameSiteNoneInsecure' | 'ExcludeSameSiteLax' | 'ExcludeSameSiteStrict' | 'ExcludeInvalidSameParty' | 'ExcludeSamePartyCrossPartyContext' | 'ExcludeDomainNonASCII' | 'ExcludeThirdPartyCookieBlockedInFirstPartySet' | 'ExcludeThirdPartyPhaseout');

        export type CookieWarningReason = ('WarnSameSiteUnspecifiedCrossSiteContext' | 'WarnSameSiteNoneInsecure' | 'WarnSameSiteUnspecifiedLaxAllowUnsafe' | 'WarnSameSiteStrictLaxDowngradeStrict' | 'WarnSameSiteStrictCrossDowngradeStrict' | 'WarnSameSiteStrictCrossDowngradeLax' | 'WarnSameSiteLaxCrossDowngradeStrict' | 'WarnSameSiteLaxCrossDowngradeLax' | 'WarnAttributeValueExceedsMaxSize' | 'WarnDomainNonASCII' | 'WarnThirdPartyPhaseout' | 'WarnCrossSiteRedirectDowngradeChangesInclusion');

        export type CookieOperation = ('SetCookie' | 'ReadCookie');

        /**
         * This information is currently necessary, as the front-end has a difficult
         * time finding a specific cookie. With this, we can convey specific error
         * information without the cookie.
         */
        export interface CookieIssueDetails {
            /**
             * If AffectedCookie is not set then rawCookieLine contains the raw
             * Set-Cookie header string. This hints at a problem where the
             * cookie line is syntactically or semantically malformed in a way
             * that no valid cookie could be created.
             */
            cookie?: AffectedCookie;
            rawCookieLine?: string;
            cookieWarningReasons: CookieWarningReason[];
            cookieExclusionReasons: CookieExclusionReason[];
            /**
             * Optionally identifies the site-for-cookies and the cookie url, which
             * may be used by the front-end as additional context.
             */
            operation: CookieOperation;
            siteForCookies?: string;
            cookieUrl?: string;
            request?: AffectedRequest;
        }

        export type MixedContentResolutionStatus = ('MixedContentBlocked' | 'MixedContentAutomaticallyUpgraded' | 'MixedContentWarning');

        export type MixedContentResourceType = ('AttributionSrc' | 'Audio' | 'Beacon' | 'CSPReport' | 'Download' | 'EventSource' | 'Favicon' | 'Font' | 'Form' | 'Frame' | 'Image' | 'Import' | 'JSON' | 'Manifest' | 'Ping' | 'PluginData' | 'PluginResource' | 'Prefetch' | 'Resource' | 'Script' | 'ServiceWorker' | 'SharedWorker' | 'SpeculationRules' | 'Stylesheet' | 'Track' | 'Video' | 'Worker' | 'XMLHttpRequest' | 'XSLT');

        export interface MixedContentIssueDetails {
            /**
             * The type of resource causing the mixed content issue (css, js, iframe,
             * form,...). Marked as optional because it is mapped to from
             * blink::mojom::RequestContextType, which will be replaced
             * by network::mojom::RequestDestination
             */
            resourceType?: MixedContentResourceType;
            /**
             * The way the mixed content issue is being resolved.
             */
            resolutionStatus: MixedContentResolutionStatus;
            /**
             * The unsafe http url causing the mixed content issue.
             */
            insecureURL: string;
            /**
             * The url responsible for the call to an unsafe url.
             */
            mainResourceURL: string;
            /**
             * The mixed content request.
             * Does not always exist (e.g. for unsafe form submission urls).
             */
            request?: AffectedRequest;
            /**
             * Optional because not every mixed content issue is necessarily linked to a frame.
             */
            frame?: AffectedFrame;
        }

        /**
         * Enum indicating the reason a response has been blocked. These reasons are
         * refinements of the net error BLOCKED_BY_RESPONSE.
         */
        export type BlockedByResponseReason = ('CoepFrameResourceNeedsCoepHeader' | 'CoopSandboxedIFrameCannotNavigateToCoopPage' | 'CorpNotSameOrigin' | 'CorpNotSameOriginAfterDefaultedToSameOriginByCoep' | 'CorpNotSameSite');

        /**
         * Details for a request that has been blocked with the BLOCKED_BY_RESPONSE
         * code. Currently only used for COEP/COOP, but may be extended to include
         * some CSP errors in the future.
         */
        export interface BlockedByResponseIssueDetails {
            request: AffectedRequest;
            parentFrame?: AffectedFrame;
            blockedFrame?: AffectedFrame;
            reason: BlockedByResponseReason;
        }

        export type HeavyAdResolutionStatus = ('HeavyAdBlocked' | 'HeavyAdWarning');

        export type HeavyAdReason = ('NetworkTotalLimit' | 'CpuTotalLimit' | 'CpuPeakLimit');

        export interface HeavyAdIssueDetails {
            /**
             * The resolution status, either blocking the content or warning.
             */
            resolution: HeavyAdResolutionStatus;
            /**
             * The reason the ad was blocked, total network or cpu or peak cpu.
             */
            reason: HeavyAdReason;
            /**
             * The frame that was blocked.
             */
            frame: AffectedFrame;
        }

        export type ContentSecurityPolicyViolationType = ('kInlineViolation' | 'kEvalViolation' | 'kURLViolation' | 'kTrustedTypesSinkViolation' | 'kTrustedTypesPolicyViolation' | 'kWasmEvalViolation');

        export interface SourceCodeLocation {
            scriptId?: Runtime.ScriptId;
            url: string;
            lineNumber: integer;
            columnNumber: integer;
        }

        export interface ContentSecurityPolicyIssueDetails {
            /**
             * The url not included in allowed sources.
             */
            blockedURL?: string;
            /**
             * Specific directive that is violated, causing the CSP issue.
             */
            violatedDirective: string;
            isReportOnly: boolean;
            contentSecurityPolicyViolationType: ContentSecurityPolicyViolationType;
            frameAncestor?: AffectedFrame;
            sourceCodeLocation?: SourceCodeLocation;
            violatingNodeId?: DOM.BackendNodeId;
        }

        export type SharedArrayBufferIssueType = ('TransferIssue' | 'CreationIssue');

        /**
         * Details for a issue arising from an SAB being instantiated in, or
         * transferred to a context that is not cross-origin isolated.
         */
        export interface SharedArrayBufferIssueDetails {
            sourceCodeLocation: SourceCodeLocation;
            isWarning: boolean;
            type: SharedArrayBufferIssueType;
        }

        export interface LowTextContrastIssueDetails {
            violatingNodeId: DOM.BackendNodeId;
            violatingNodeSelector: string;
            contrastRatio: number;
            thresholdAA: number;
            thresholdAAA: number;
            fontSize: string;
            fontWeight: string;
        }

        /**
         * Details for a CORS related issue, e.g. a warning or error related to
         * CORS RFC1918 enforcement.
         */
        export interface CorsIssueDetails {
            corsErrorStatus: Network.CorsErrorStatus;
            isWarning: boolean;
            request: AffectedRequest;
            location?: SourceCodeLocation;
            initiatorOrigin?: string;
            resourceIPAddressSpace?: Network.IPAddressSpace;
            clientSecurityState?: Network.ClientSecurityState;
        }

        export type AttributionReportingIssueType = ('PermissionPolicyDisabled' | 'UntrustworthyReportingOrigin' | 'InsecureContext' | 'InvalidHeader' | 'InvalidRegisterTriggerHeader' | 'SourceAndTriggerHeaders' | 'SourceIgnored' | 'TriggerIgnored' | 'OsSourceIgnored' | 'OsTriggerIgnored' | 'InvalidRegisterOsSourceHeader' | 'InvalidRegisterOsTriggerHeader' | 'WebAndOsHeaders' | 'NoWebOrOsSupport' | 'NavigationRegistrationWithoutTransientUserActivation' | 'InvalidInfoHeader' | 'NoRegisterSourceHeader' | 'NoRegisterTriggerHeader' | 'NoRegisterOsSourceHeader' | 'NoRegisterOsTriggerHeader');

        /**
         * Details for issues around "Attribution Reporting API" usage.
         * Explainer: https://github.com/WICG/attribution-reporting-api
         */
        export interface AttributionReportingIssueDetails {
            violationType: AttributionReportingIssueType;
            request?: AffectedRequest;
            violatingNodeId?: DOM.BackendNodeId;
            invalidParameter?: string;
        }

        /**
         * Details for issues about documents in Quirks Mode
         * or Limited Quirks Mode that affects page layouting.
         */
        export interface QuirksModeIssueDetails {
            /**
             * If false, it means the document's mode is "quirks"
             * instead of "limited-quirks".
             */
            isLimitedQuirksMode: boolean;
            documentNodeId: DOM.BackendNodeId;
            url: string;
            frameId: Page.FrameId;
            loaderId: Network.LoaderId;
        }

        export interface NavigatorUserAgentIssueDetails {
            url: string;
            location?: SourceCodeLocation;
        }

        export type GenericIssueErrorType = ('CrossOriginPortalPostMessageError' | 'FormLabelForNameError' | 'FormDuplicateIdForInputError' | 'FormInputWithNoLabelError' | 'FormAutocompleteAttributeEmptyError' | 'FormEmptyIdAndNameAttributesForInputError' | 'FormAriaLabelledByToNonExistingId' | 'FormInputAssignedAutocompleteValueToIdOrNameAttributeError' | 'FormLabelHasNeitherForNorNestedInput' | 'FormLabelForMatchesNonExistingIdError' | 'FormInputHasWrongButWellIntendedAutocompleteValueError' | 'ResponseWasBlockedByORB');

        /**
         * Depending on the concrete errorType, different properties are set.
         */
        export interface GenericIssueDetails {
            /**
             * Issues with the same errorType are aggregated in the frontend.
             */
            errorType: GenericIssueErrorType;
            frameId?: Page.FrameId;
            violatingNodeId?: DOM.BackendNodeId;
            violatingNodeAttribute?: string;
            request?: AffectedRequest;
        }

        /**
         * This issue tracks information needed to print a deprecation message.
         * https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/frame/third_party/blink/renderer/core/frame/deprecation/README.md
         */
        export interface DeprecationIssueDetails {
            affectedFrame?: AffectedFrame;
            sourceCodeLocation: SourceCodeLocation;
            /**
             * One of the deprecation names from third_party/blink/renderer/core/frame/deprecation/deprecation.json5
             */
            type: string;
        }

        /**
         * This issue warns about sites in the redirect chain of a finished navigation
         * that may be flagged as trackers and have their state cleared if they don't
         * receive a user interaction. Note that in this context 'site' means eTLD+1.
         * For example, if the URL `https://example.test:80/bounce` was in the
         * redirect chain, the site reported would be `example.test`.
         */
        export interface BounceTrackingIssueDetails {
            trackingSites: string[];
        }

        /**
         * This issue warns about third-party sites that are accessing cookies on the
         * current page, and have been permitted due to having a global metadata grant.
         * Note that in this context 'site' means eTLD+1. For example, if the URL
         * `https://example.test:80/web_page` was accessing cookies, the site reported
         * would be `example.test`.
         */
        export interface CookieDeprecationMetadataIssueDetails {
            allowedSites: string[];
        }

        export type ClientHintIssueReason = ('MetaTagAllowListInvalidOrigin' | 'MetaTagModifiedHTML');

        export interface FederatedAuthRequestIssueDetails {
            federatedAuthRequestIssueReason: FederatedAuthRequestIssueReason;
        }

        /**
         * Represents the failure reason when a federated authentication reason fails.
         * Should be updated alongside RequestIdTokenStatus in
         * third_party/blink/public/mojom/devtools/inspector_issue.mojom to include
         * all cases except for success.
         */
        export type FederatedAuthRequestIssueReason = ('ShouldEmbargo' | 'TooManyRequests' | 'WellKnownHttpNotFound' | 'WellKnownNoResponse' | 'WellKnownInvalidResponse' | 'WellKnownListEmpty' | 'WellKnownInvalidContentType' | 'ConfigNotInWellKnown' | 'WellKnownTooBig' | 'ConfigHttpNotFound' | 'ConfigNoResponse' | 'ConfigInvalidResponse' | 'ConfigInvalidContentType' | 'ClientMetadataHttpNotFound' | 'ClientMetadataNoResponse' | 'ClientMetadataInvalidResponse' | 'ClientMetadataInvalidContentType' | 'DisabledInSettings' | 'ErrorFetchingSignin' | 'InvalidSigninResponse' | 'AccountsHttpNotFound' | 'AccountsNoResponse' | 'AccountsInvalidResponse' | 'AccountsListEmpty' | 'AccountsInvalidContentType' | 'IdTokenHttpNotFound' | 'IdTokenNoResponse' | 'IdTokenInvalidResponse' | 'IdTokenIdpErrorResponse' | 'IdTokenCrossSiteIdpErrorResponse' | 'IdTokenInvalidRequest' | 'IdTokenInvalidContentType' | 'ErrorIdToken' | 'Canceled' | 'RpPageNotVisible' | 'SilentMediationFailure' | 'ThirdPartyCookiesBlocked' | 'NotSignedInWithIdp' | 'MissingTransientUserActivation' | 'ReplacedByButtonMode');

        export interface FederatedAuthUserInfoRequestIssueDetails {
            federatedAuthUserInfoRequestIssueReason: FederatedAuthUserInfoRequestIssueReason;
        }

        /**
         * Represents the failure reason when a getUserInfo() call fails.
         * Should be updated alongside FederatedAuthUserInfoRequestResult in
         * third_party/blink/public/mojom/devtools/inspector_issue.mojom.
         */
        export type FederatedAuthUserInfoRequestIssueReason = ('NotSameOrigin' | 'NotIframe' | 'NotPotentiallyTrustworthy' | 'NoApiPermission' | 'NotSignedInWithIdp' | 'NoAccountSharingPermission' | 'InvalidConfigOrWellKnown' | 'InvalidAccountsResponse' | 'NoReturningUserFromFetchedAccounts');

        /**
         * This issue tracks client hints related issues. It's used to deprecate old
         * features, encourage the use of new ones, and provide general guidance.
         */
        export interface ClientHintIssueDetails {
            sourceCodeLocation: SourceCodeLocation;
            clientHintIssueReason: ClientHintIssueReason;
        }

        export interface FailedRequestInfo {
            /**
             * The URL that failed to load.
             */
            url: string;
            /**
             * The failure message for the failed request.
             */
            failureMessage: string;
            requestId?: Network.RequestId;
        }

        export type StyleSheetLoadingIssueReason = ('LateImportRule' | 'RequestFailed');

        /**
         * This issue warns when a referenced stylesheet couldn't be loaded.
         */
        export interface StylesheetLoadingIssueDetails {
            /**
             * Source code position that referenced the failing stylesheet.
             */
            sourceCodeLocation: SourceCodeLocation;
            /**
             * Reason why the stylesheet couldn't be loaded.
             */
            styleSheetLoadingIssueReason: StyleSheetLoadingIssueReason;
            /**
             * Contains additional info when the failure was due to a request.
             */
            failedRequestInfo?: FailedRequestInfo;
        }

        export type PropertyRuleIssueReason = ('InvalidSyntax' | 'InvalidInitialValue' | 'InvalidInherits' | 'InvalidName');

        /**
         * This issue warns about errors in property rules that lead to property
         * registrations being ignored.
         */
        export interface PropertyRuleIssueDetails {
            /**
             * Source code position of the property rule.
             */
            sourceCodeLocation: SourceCodeLocation;
            /**
             * Reason why the property rule was discarded.
             */
            propertyRuleIssueReason: PropertyRuleIssueReason;
            /**
             * The value of the property rule property that failed to parse
             */
            propertyValue?: string;
        }

        /**
         * A unique identifier for the type of issue. Each type may use one of the
         * optional fields in InspectorIssueDetails to convey more specific
         * information about the kind of issue.
         */
        export type InspectorIssueCode = ('CookieIssue' | 'MixedContentIssue' | 'BlockedByResponseIssue' | 'HeavyAdIssue' | 'ContentSecurityPolicyIssue' | 'SharedArrayBufferIssue' | 'LowTextContrastIssue' | 'CorsIssue' | 'AttributionReportingIssue' | 'QuirksModeIssue' | 'NavigatorUserAgentIssue' | 'GenericIssue' | 'DeprecationIssue' | 'ClientHintIssue' | 'FederatedAuthRequestIssue' | 'BounceTrackingIssue' | 'CookieDeprecationMetadataIssue' | 'StylesheetLoadingIssue' | 'FederatedAuthUserInfoRequestIssue' | 'PropertyRuleIssue');

        /**
         * This struct holds a list of optional fields with additional information
         * specific to the kind of issue. When adding a new issue code, please also
         * add a new optional field to this type.
         */
        export interface InspectorIssueDetails {
            cookieIssueDetails?: CookieIssueDetails;
            mixedContentIssueDetails?: MixedContentIssueDetails;
            blockedByResponseIssueDetails?: BlockedByResponseIssueDetails;
            heavyAdIssueDetails?: HeavyAdIssueDetails;
            contentSecurityPolicyIssueDetails?: ContentSecurityPolicyIssueDetails;
            sharedArrayBufferIssueDetails?: SharedArrayBufferIssueDetails;
            lowTextContrastIssueDetails?: LowTextContrastIssueDetails;
            corsIssueDetails?: CorsIssueDetails;
            attributionReportingIssueDetails?: AttributionReportingIssueDetails;
            quirksModeIssueDetails?: QuirksModeIssueDetails;
            navigatorUserAgentIssueDetails?: NavigatorUserAgentIssueDetails;
            genericIssueDetails?: GenericIssueDetails;
            deprecationIssueDetails?: DeprecationIssueDetails;
            clientHintIssueDetails?: ClientHintIssueDetails;
            federatedAuthRequestIssueDetails?: FederatedAuthRequestIssueDetails;
            bounceTrackingIssueDetails?: BounceTrackingIssueDetails;
            cookieDeprecationMetadataIssueDetails?: CookieDeprecationMetadataIssueDetails;
            stylesheetLoadingIssueDetails?: StylesheetLoadingIssueDetails;
            propertyRuleIssueDetails?: PropertyRuleIssueDetails;
            federatedAuthUserInfoRequestIssueDetails?: FederatedAuthUserInfoRequestIssueDetails;
        }

        /**
         * A unique id for a DevTools inspector issue. Allows other entities (e.g.
         * exceptions, CDP message, console messages, etc.) to reference an issue.
         */
        export type IssueId = string;

        /**
         * An inspector issue reported from the back-end.
         */
        export interface InspectorIssue {
            code: InspectorIssueCode;
            details: InspectorIssueDetails;
            /**
             * A unique id for this issue. May be omitted if no other entity (e.g.
             * exception, CDP message, etc.) is referencing this issue.
             */
            issueId?: IssueId;
        }

        export const enum GetEncodedResponseRequestEncoding {
            Webp = 'webp',
            Jpeg = 'jpeg',
            Png = 'png',
        }

        export interface GetEncodedResponseRequest {
            /**
             * Identifier of the network request to get content for.
             */
            requestId: Network.RequestId;
            /**
             * The encoding to use. (GetEncodedResponseRequestEncoding enum)
             */
            encoding: ('webp' | 'jpeg' | 'png');
            /**
             * The quality of the encoding (0-1). (defaults to 1)
             */
            quality?: number;
            /**
             * Whether to only return the size information (defaults to false).
             */
            sizeOnly?: boolean;
        }

        export interface GetEncodedResponseResponse {
            /**
             * The encoded body as a base64 string. Omitted if sizeOnly is true. (Encoded as a base64 string when passed over JSON)
             */
            body?: string;
            /**
             * Size before re-encoding.
             */
            originalSize: integer;
            /**
             * Size after re-encoding.
             */
            encodedSize: integer;
        }

        export interface CheckContrastRequest {
            /**
             * Whether to report WCAG AAA level issues. Default is false.
             */
            reportAAA?: boolean;
        }

        export interface CheckFormsIssuesResponse {
            formIssues: GenericIssueDetails[];
        }

        export interface IssueAddedEvent {
            issue: InspectorIssue;
        }
    }

    /**
     * Defines commands and events for Autofill.
     */
    export namespace Autofill {

        export interface CreditCard {
            /**
             * 16-digit credit card number.
             */
            number: string;
            /**
             * Name of the credit card owner.
             */
            name: string;
            /**
             * 2-digit expiry month.
             */
            expiryMonth: string;
            /**
             * 4-digit expiry year.
             */
            expiryYear: string;
            /**
             * 3-digit card verification code.
             */
            cvc: string;
        }

        export interface AddressField {
            /**
             * address field name, for example GIVEN_NAME.
             */
            name: string;
            /**
             * address field value, for example Jon Doe.
             */
            value: string;
        }

        /**
         * A list of address fields.
         */
        export interface AddressFields {
            fields: AddressField[];
        }

        export interface Address {
            /**
             * fields and values defining an address.
             */
            fields: AddressField[];
        }

        /**
         * Defines how an address can be displayed like in chrome://settings/addresses.
         * Address UI is a two dimensional array, each inner array is an "address information line", and when rendered in a UI surface should be displayed as such.
         * The following address UI for instance:
         * [[{name: "GIVE_NAME", value: "Jon"}, {name: "FAMILY_NAME", value: "Doe"}], [{name: "CITY", value: "Munich"}, {name: "ZIP", value: "81456"}]]
         * should allow the receiver to render:
         * Jon Doe
         * Munich 81456
         */
        export interface AddressUI {
            /**
             * A two dimension array containing the representation of values from an address profile.
             */
            addressFields: AddressFields[];
        }

        /**
         * Specified whether a filled field was done so by using the html autocomplete attribute or autofill heuristics.
         */
        export type FillingStrategy = ('autocompleteAttribute' | 'autofillInferred');

        export interface FilledField {
            /**
             * The type of the field, e.g text, password etc.
             */
            htmlType: string;
            /**
             * the html id
             */
            id: string;
            /**
             * the html name
             */
            name: string;
            /**
             * the field value
             */
            value: string;
            /**
             * The actual field type, e.g FAMILY_NAME
             */
            autofillType: string;
            /**
             * The filling strategy
             */
            fillingStrategy: FillingStrategy;
            /**
             * The frame the field belongs to
             */
            frameId: Page.FrameId;
            /**
             * The form field's DOM node
             */
            fieldId: DOM.BackendNodeId;
        }

        export interface TriggerRequest {
            /**
             * Identifies a field that serves as an anchor for autofill.
             */
            fieldId: DOM.BackendNodeId;
            /**
             * Identifies the frame that field belongs to.
             */
            frameId?: Page.FrameId;
            /**
             * Credit card information to fill out the form. Credit card data is not saved.
             */
            card: CreditCard;
        }

        export interface SetAddressesRequest {
            addresses: Address[];
        }

        /**
         * Emitted when an address form is filled.
         */
        export interface AddressFormFilledEvent {
            /**
             * Information about the fields that were filled
             */
            filledFields: FilledField[];
            /**
             * An UI representation of the address used to fill the form.
             * Consists of a 2D array where each child represents an address/profile line.
             */
            addressUi: AddressUI;
        }
    }

    /**
     * Defines events for background web platform features.
     */
    export namespace BackgroundService {

        /**
         * The Background Service that will be associated with the commands/events.
         * Every Background Service operates independently, but they share the same
         * API.
         */
        export type ServiceName = ('backgroundFetch' | 'backgroundSync' | 'pushMessaging' | 'notifications' | 'paymentHandler' | 'periodicBackgroundSync');

        /**
         * A key-value pair for additional event information to pass along.
         */
        export interface EventMetadata {
            key: string;
            value: string;
        }

        export interface BackgroundServiceEvent {
            /**
             * Timestamp of the event (in seconds).
             */
            timestamp: Network.TimeSinceEpoch;
            /**
             * The origin this event belongs to.
             */
            origin: string;
            /**
             * The Service Worker ID that initiated the event.
             */
            serviceWorkerRegistrationId: ServiceWorker.RegistrationID;
            /**
             * The Background Service this event belongs to.
             */
            service: ServiceName;
            /**
             * A description of the event.
             */
            eventName: string;
            /**
             * An identifier that groups related events together.
             */
            instanceId: string;
            /**
             * A list of event-specific information.
             */
            eventMetadata: EventMetadata[];
            /**
             * Storage key this event belongs to.
             */
            storageKey: string;
        }

        export interface StartObservingRequest {
            service: ServiceName;
        }

        export interface StopObservingRequest {
            service: ServiceName;
        }

        export interface SetRecordingRequest {
            shouldRecord: boolean;
            service: ServiceName;
        }

        export interface ClearEventsRequest {
            service: ServiceName;
        }

        /**
         * Called when the recording state for the service has been updated.
         */
        export interface RecordingStateChangedEvent {
            isRecording: boolean;
            service: ServiceName;
        }

        /**
         * Called with all existing backgroundServiceEvents when enabled, and all new
         * events afterwards if enabled and recording.
         */
        export interface BackgroundServiceEventReceivedEvent {
            backgroundServiceEvent: BackgroundServiceEvent;
        }
    }

    /**
     * The Browser domain defines methods and events for browser managing.
     */
    export namespace Browser {

        export type BrowserContextID = string;

        export type WindowID = integer;

        /**
         * The state of the browser window.
         */
        export type WindowState = ('normal' | 'minimized' | 'maximized' | 'fullscreen');

        /**
         * Browser window bounds information
         */
        export interface Bounds {
            /**
             * The offset from the left edge of the screen to the window in pixels.
             */
            left?: integer;
            /**
             * The offset from the top edge of the screen to the window in pixels.
             */
            top?: integer;
            /**
             * The window width in pixels.
             */
            width?: integer;
            /**
             * The window height in pixels.
             */
            height?: integer;
            /**
             * The window state. Default to normal.
             */
            windowState?: WindowState;
        }

        export type PermissionType = ('accessibilityEvents' | 'audioCapture' | 'backgroundSync' | 'backgroundFetch' | 'capturedSurfaceControl' | 'clipboardReadWrite' | 'clipboardSanitizedWrite' | 'displayCapture' | 'durableStorage' | 'flash' | 'geolocation' | 'idleDetection' | 'localFonts' | 'midi' | 'midiSysex' | 'nfc' | 'notifications' | 'paymentHandler' | 'periodicBackgroundSync' | 'protectedMediaIdentifier' | 'sensors' | 'storageAccess' | 'speakerSelection' | 'topLevelStorageAccess' | 'videoCapture' | 'videoCapturePanTiltZoom' | 'wakeLockScreen' | 'wakeLockSystem' | 'windowManagement');

        export type PermissionSetting = ('granted' | 'denied' | 'prompt');

        /**
         * Definition of PermissionDescriptor defined in the Permissions API:
         * https://w3c.github.io/permissions/#dom-permissiondescriptor.
         */
        export interface PermissionDescriptor {
            /**
             * Name of permission.
             * See https://cs.chromium.org/chromium/src/third_party/blink/renderer/modules/permissions/permission_descriptor.idl for valid permission names.
             */
            name: string;
            /**
             * For "midi" permission, may also specify sysex control.
             */
            sysex?: boolean;
            /**
             * For "push" permission, may specify userVisibleOnly.
             * Note that userVisibleOnly = true is the only currently supported type.
             */
            userVisibleOnly?: boolean;
            /**
             * For "clipboard" permission, may specify allowWithoutSanitization.
             */
            allowWithoutSanitization?: boolean;
            /**
             * For "camera" permission, may specify panTiltZoom.
             */
            panTiltZoom?: boolean;
        }

        /**
         * Browser command ids used by executeBrowserCommand.
         */
        export type BrowserCommandId = ('openTabSearch' | 'closeTabSearch');

        /**
         * Chrome histogram bucket.
         */
        export interface Bucket {
            /**
             * Minimum value (inclusive).
             */
            low: integer;
            /**
             * Maximum value (exclusive).
             */
            high: integer;
            /**
             * Number of samples.
             */
            count: integer;
        }

        /**
         * Chrome histogram.
         */
        export interface Histogram {
            /**
             * Name.
             */
            name: string;
            /**
             * Sum of sample values.
             */
            sum: integer;
            /**
             * Total number of samples.
             */
            count: integer;
            /**
             * Buckets.
             */
            buckets: Bucket[];
        }

        export interface SetPermissionRequest {
            /**
             * Descriptor of permission to override.
             */
            permission: PermissionDescriptor;
            /**
             * Setting of the permission.
             */
            setting: PermissionSetting;
            /**
             * Origin the permission applies to, all origins if not specified.
             */
            origin?: string;
            /**
             * Context to override. When omitted, default browser context is used.
             */
            browserContextId?: BrowserContextID;
        }

        export interface GrantPermissionsRequest {
            permissions: PermissionType[];
            /**
             * Origin the permission applies to, all origins if not specified.
             */
            origin?: string;
            /**
             * BrowserContext to override permissions. When omitted, default browser context is used.
             */
            browserContextId?: BrowserContextID;
        }

        export interface ResetPermissionsRequest {
            /**
             * BrowserContext to reset permissions. When omitted, default browser context is used.
             */
            browserContextId?: BrowserContextID;
        }

        export const enum SetDownloadBehaviorRequestBehavior {
            Deny = 'deny',
            Allow = 'allow',
            AllowAndName = 'allowAndName',
            Default = 'default',
        }

        export interface SetDownloadBehaviorRequest {
            /**
             * Whether to allow all or deny all download requests, or use default Chrome behavior if
             * available (otherwise deny). |allowAndName| allows download and names files according to
             * their download guids. (SetDownloadBehaviorRequestBehavior enum)
             */
            behavior: ('deny' | 'allow' | 'allowAndName' | 'default');
            /**
             * BrowserContext to set download behavior. When omitted, default browser context is used.
             */
            browserContextId?: BrowserContextID;
            /**
             * The default path to save downloaded files to. This is required if behavior is set to 'allow'
             * or 'allowAndName'.
             */
            downloadPath?: string;
            /**
             * Whether to emit download events (defaults to false).
             */
            eventsEnabled?: boolean;
        }

        export interface CancelDownloadRequest {
            /**
             * Global unique identifier of the download.
             */
            guid: string;
            /**
             * BrowserContext to perform the action in. When omitted, default browser context is used.
             */
            browserContextId?: BrowserContextID;
        }

        export interface GetVersionResponse {
            /**
             * Protocol version.
             */
            protocolVersion: string;
            /**
             * Product name.
             */
            product: string;
            /**
             * Product revision.
             */
            revision: string;
            /**
             * User-Agent.
             */
            userAgent: string;
            /**
             * V8 version.
             */
            jsVersion: string;
        }

        export interface GetBrowserCommandLineResponse {
            /**
             * Commandline parameters
             */
            arguments: string[];
        }

        export interface GetHistogramsRequest {
            /**
             * Requested substring in name. Only histograms which have query as a
             * substring in their name are extracted. An empty or absent query returns
             * all histograms.
             */
            query?: string;
            /**
             * If true, retrieve delta since last delta call.
             */
            delta?: boolean;
        }

        export interface GetHistogramsResponse {
            /**
             * Histograms.
             */
            histograms: Histogram[];
        }

        export interface GetHistogramRequest {
            /**
             * Requested histogram name.
             */
            name: string;
            /**
             * If true, retrieve delta since last delta call.
             */
            delta?: boolean;
        }

        export interface GetHistogramResponse {
            /**
             * Histogram.
             */
            histogram: Histogram;
        }

        export interface GetWindowBoundsRequest {
            /**
             * Browser window id.
             */
            windowId: WindowID;
        }

        export interface GetWindowBoundsResponse {
            /**
             * Bounds information of the window. When window state is 'minimized', the restored window
             * position and size are returned.
             */
            bounds: Bounds;
        }

        export interface GetWindowForTargetRequest {
            /**
             * Devtools agent host id. If called as a part of the session, associated targetId is used.
             */
            targetId?: Target.TargetID;
        }

        export interface GetWindowForTargetResponse {
            /**
             * Browser window id.
             */
            windowId: WindowID;
            /**
             * Bounds information of the window. When window state is 'minimized', the restored window
             * position and size are returned.
             */
            bounds: Bounds;
        }

        export interface SetWindowBoundsRequest {
            /**
             * Browser window id.
             */
            windowId: WindowID;
            /**
             * New window bounds. The 'minimized', 'maximized' and 'fullscreen' states cannot be combined
             * with 'left', 'top', 'width' or 'height'. Leaves unspecified fields unchanged.
             */
            bounds: Bounds;
        }

        export interface SetDockTileRequest {
            badgeLabel?: string;
            /**
             * Png encoded image. (Encoded as a base64 string when passed over JSON)
             */
            image?: string;
        }

        export interface ExecuteBrowserCommandRequest {
            commandId: BrowserCommandId;
        }

        export interface AddPrivacySandboxEnrollmentOverrideRequest {
            url: string;
        }

        /**
         * Fired when page is about to start a download.
         */
        export interface DownloadWillBeginEvent {
            /**
             * Id of the frame that caused the download to begin.
             */
            frameId: Page.FrameId;
            /**
             * Global unique identifier of the download.
             */
            guid: string;
            /**
             * URL of the resource being downloaded.
             */
            url: string;
            /**
             * Suggested file name of the resource (the actual name of the file saved on disk may differ).
             */
            suggestedFilename: string;
        }

        export const enum DownloadProgressEventState {
            InProgress = 'inProgress',
            Completed = 'completed',
            Canceled = 'canceled',
        }

        /**
         * Fired when download makes progress. Last call has |done| == true.
         */
        export interface DownloadProgressEvent {
            /**
             * Global unique identifier of the download.
             */
            guid: string;
            /**
             * Total expected bytes to download.
             */
            totalBytes: number;
            /**
             * Total bytes received.
             */
            receivedBytes: number;
            /**
             * Download status. (DownloadProgressEventState enum)
             */
            state: ('inProgress' | 'completed' | 'canceled');
        }
    }

    /**
     * This domain exposes CSS read/write operations. All CSS objects (stylesheets, rules, and styles)
     * have an associated `id` used in subsequent operations on the related object. Each object type has
     * a specific `id` structure, and those are not interchangeable between objects of different kinds.
     * CSS objects can be loaded using the `get*ForNode()` calls (which accept a DOM node id). A client
     * can also keep track of stylesheets via the `styleSheetAdded`/`styleSheetRemoved` events and
     * subsequently load the required stylesheet contents using the `getStyleSheet[Text]()` methods.
     */
    export namespace CSS {

        export type StyleSheetId = string;

        /**
         * Stylesheet type: "injected" for stylesheets injected via extension, "user-agent" for user-agent
         * stylesheets, "inspector" for stylesheets created by the inspector (i.e. those holding the "via
         * inspector" rules), "regular" for regular stylesheets.
         */
        export type StyleSheetOrigin = ('injected' | 'user-agent' | 'inspector' | 'regular');

        /**
         * CSS rule collection for a single pseudo style.
         */
        export interface PseudoElementMatches {
            /**
             * Pseudo element type.
             */
            pseudoType: DOM.PseudoType;
            /**
             * Pseudo element custom ident.
             */
            pseudoIdentifier?: string;
            /**
             * Matches of CSS rules applicable to the pseudo style.
             */
            matches: RuleMatch[];
        }

        /**
         * Inherited CSS rule collection from ancestor node.
         */
        export interface InheritedStyleEntry {
            /**
             * The ancestor node's inline style, if any, in the style inheritance chain.
             */
            inlineStyle?: CSSStyle;
            /**
             * Matches of CSS rules matching the ancestor node in the style inheritance chain.
             */
            matchedCSSRules: RuleMatch[];
        }

        /**
         * Inherited pseudo element matches from pseudos of an ancestor node.
         */
        export interface InheritedPseudoElementMatches {
            /**
             * Matches of pseudo styles from the pseudos of an ancestor node.
             */
            pseudoElements: PseudoElementMatches[];
        }

        /**
         * Match data for a CSS rule.
         */
        export interface RuleMatch {
            /**
             * CSS rule in the match.
             */
            rule: CSSRule;
            /**
             * Matching selector indices in the rule's selectorList selectors (0-based).
             */
            matchingSelectors: integer[];
        }

        /**
         * Data for a simple selector (these are delimited by commas in a selector list).
         */
        export interface Value {
            /**
             * Value text.
             */
            text: string;
            /**
             * Value range in the underlying resource (if available).
             */
            range?: SourceRange;
            /**
             * Specificity of the selector.
             */
            specificity?: Specificity;
        }

        /**
         * Specificity:
         * https://drafts.csswg.org/selectors/#specificity-rules
         */
        export interface Specificity {
            /**
             * The a component, which represents the number of ID selectors.
             */
            a: integer;
            /**
             * The b component, which represents the number of class selectors, attributes selectors, and
             * pseudo-classes.
             */
            b: integer;
            /**
             * The c component, which represents the number of type selectors and pseudo-elements.
             */
            c: integer;
        }

        /**
         * Selector list data.
         */
        export interface SelectorList {
            /**
             * Selectors in the list.
             */
            selectors: Value[];
            /**
             * Rule selector text.
             */
            text: string;
        }

        /**
         * CSS stylesheet metainformation.
         */
        export interface CSSStyleSheetHeader {
            /**
             * The stylesheet identifier.
             */
            styleSheetId: StyleSheetId;
            /**
             * Owner frame identifier.
             */
            frameId: Page.FrameId;
            /**
             * Stylesheet resource URL. Empty if this is a constructed stylesheet created using
             * new CSSStyleSheet() (but non-empty if this is a constructed stylesheet imported
             * as a CSS module script).
             */
            sourceURL: string;
            /**
             * URL of source map associated with the stylesheet (if any).
             */
            sourceMapURL?: string;
            /**
             * Stylesheet origin.
             */
            origin: StyleSheetOrigin;
            /**
             * Stylesheet title.
             */
            title: string;
            /**
             * The backend id for the owner node of the stylesheet.
             */
            ownerNode?: DOM.BackendNodeId;
            /**
             * Denotes whether the stylesheet is disabled.
             */
            disabled: boolean;
            /**
             * Whether the sourceURL field value comes from the sourceURL comment.
             */
            hasSourceURL?: boolean;
            /**
             * Whether this stylesheet is created for STYLE tag by parser. This flag is not set for
             * document.written STYLE tags.
             */
            isInline: boolean;
            /**
             * Whether this stylesheet is mutable. Inline stylesheets become mutable
             * after they have been modified via CSSOM API.
             * `<link>` element's stylesheets become mutable only if DevTools modifies them.
             * Constructed stylesheets (new CSSStyleSheet()) are mutable immediately after creation.
             */
            isMutable: boolean;
            /**
             * True if this stylesheet is created through new CSSStyleSheet() or imported as a
             * CSS module script.
             */
            isConstructed: boolean;
            /**
             * Line offset of the stylesheet within the resource (zero based).
             */
            startLine: number;
            /**
             * Column offset of the stylesheet within the resource (zero based).
             */
            startColumn: number;
            /**
             * Size of the content (in characters).
             */
            length: number;
            /**
             * Line offset of the end of the stylesheet within the resource (zero based).
             */
            endLine: number;
            /**
             * Column offset of the end of the stylesheet within the resource (zero based).
             */
            endColumn: number;
            /**
             * If the style sheet was loaded from a network resource, this indicates when the resource failed to load
             */
            loadingFailed?: boolean;
        }

        /**
         * CSS rule representation.
         */
        export interface CSSRule {
            /**
             * The css style sheet identifier (absent for user agent stylesheet and user-specified
             * stylesheet rules) this rule came from.
             */
            styleSheetId?: StyleSheetId;
            /**
             * Rule selector data.
             */
            selectorList: SelectorList;
            /**
             * Array of selectors from ancestor style rules, sorted by distance from the current rule.
             */
            nestingSelectors?: string[];
            /**
             * Parent stylesheet's origin.
             */
            origin: StyleSheetOrigin;
            /**
             * Associated style declaration.
             */
            style: CSSStyle;
            /**
             * Media list array (for rules involving media queries). The array enumerates media queries
             * starting with the innermost one, going outwards.
             */
            media?: CSSMedia[];
            /**
             * Container query list array (for rules involving container queries).
             * The array enumerates container queries starting with the innermost one, going outwards.
             */
            containerQueries?: CSSContainerQuery[];
            /**
             * @supports CSS at-rule array.
             * The array enumerates @supports at-rules starting with the innermost one, going outwards.
             */
            supports?: CSSSupports[];
            /**
             * Cascade layer array. Contains the layer hierarchy that this rule belongs to starting
             * with the innermost layer and going outwards.
             */
            layers?: CSSLayer[];
            /**
             * @scope CSS at-rule array.
             * The array enumerates @scope at-rules starting with the innermost one, going outwards.
             */
            scopes?: CSSScope[];
            /**
             * The array keeps the types of ancestor CSSRules from the innermost going outwards.
             */
            ruleTypes?: CSSRuleType[];
        }

        /**
         * Enum indicating the type of a CSS rule, used to represent the order of a style rule's ancestors.
         * This list only contains rule types that are collected during the ancestor rule collection.
         */
        export type CSSRuleType = ('MediaRule' | 'SupportsRule' | 'ContainerRule' | 'LayerRule' | 'ScopeRule' | 'StyleRule');

        /**
         * CSS coverage information.
         */
        export interface RuleUsage {
            /**
             * The css style sheet identifier (absent for user agent stylesheet and user-specified
             * stylesheet rules) this rule came from.
             */
            styleSheetId: StyleSheetId;
            /**
             * Offset of the start of the rule (including selector) from the beginning of the stylesheet.
             */
            startOffset: number;
            /**
             * Offset of the end of the rule body from the beginning of the stylesheet.
             */
            endOffset: number;
            /**
             * Indicates whether the rule was actually used by some element in the page.
             */
            used: boolean;
        }

        /**
         * Text range within a resource. All numbers are zero-based.
         */
        export interface SourceRange {
            /**
             * Start line of range.
             */
            startLine: integer;
            /**
             * Start column of range (inclusive).
             */
            startColumn: integer;
            /**
             * End line of range
             */
            endLine: integer;
            /**
             * End column of range (exclusive).
             */
            endColumn: integer;
        }

        export interface ShorthandEntry {
            /**
             * Shorthand name.
             */
            name: string;
            /**
             * Shorthand value.
             */
            value: string;
            /**
             * Whether the property has "!important" annotation (implies `false` if absent).
             */
            important?: boolean;
        }

        export interface CSSComputedStyleProperty {
            /**
             * Computed style property name.
             */
            name: string;
            /**
             * Computed style property value.
             */
            value: string;
        }

        /**
         * CSS style representation.
         */
        export interface CSSStyle {
            /**
             * The css style sheet identifier (absent for user agent stylesheet and user-specified
             * stylesheet rules) this rule came from.
             */
            styleSheetId?: StyleSheetId;
            /**
             * CSS properties in the style.
             */
            cssProperties: CSSProperty[];
            /**
             * Computed values for all shorthands found in the style.
             */
            shorthandEntries: ShorthandEntry[];
            /**
             * Style declaration text (if available).
             */
            cssText?: string;
            /**
             * Style declaration range in the enclosing stylesheet (if available).
             */
            range?: SourceRange;
        }

        /**
         * CSS property declaration data.
         */
        export interface CSSProperty {
            /**
             * The property name.
             */
            name: string;
            /**
             * The property value.
             */
            value: string;
            /**
             * Whether the property has "!important" annotation (implies `false` if absent).
             */
            important?: boolean;
            /**
             * Whether the property is implicit (implies `false` if absent).
             */
            implicit?: boolean;
            /**
             * The full property text as specified in the style.
             */
            text?: string;
            /**
             * Whether the property is understood by the browser (implies `true` if absent).
             */
            parsedOk?: boolean;
            /**
             * Whether the property is disabled by the user (present for source-based properties only).
             */
            disabled?: boolean;
            /**
             * The entire property range in the enclosing style declaration (if available).
             */
            range?: SourceRange;
            /**
             * Parsed longhand components of this property if it is a shorthand.
             * This field will be empty if the given property is not a shorthand.
             */
            longhandProperties?: CSSProperty[];
        }

        export const enum CSSMediaSource {
            MediaRule = 'mediaRule',
            ImportRule = 'importRule',
            LinkedSheet = 'linkedSheet',
            InlineSheet = 'inlineSheet',
        }

        /**
         * CSS media rule descriptor.
         */
        export interface CSSMedia {
            /**
             * Media query text.
             */
            text: string;
            /**
             * Source of the media query: "mediaRule" if specified by a @media rule, "importRule" if
             * specified by an @import rule, "linkedSheet" if specified by a "media" attribute in a linked
             * stylesheet's LINK tag, "inlineSheet" if specified by a "media" attribute in an inline
             * stylesheet's STYLE tag. (CSSMediaSource enum)
             */
            source: ('mediaRule' | 'importRule' | 'linkedSheet' | 'inlineSheet');
            /**
             * URL of the document containing the media query description.
             */
            sourceURL?: string;
            /**
             * The associated rule (@media or @import) header range in the enclosing stylesheet (if
             * available).
             */
            range?: SourceRange;
            /**
             * Identifier of the stylesheet containing this object (if exists).
             */
            styleSheetId?: StyleSheetId;
            /**
             * Array of media queries.
             */
            mediaList?: MediaQuery[];
        }

        /**
         * Media query descriptor.
         */
        export interface MediaQuery {
            /**
             * Array of media query expressions.
             */
            expressions: MediaQueryExpression[];
            /**
             * Whether the media query condition is satisfied.
             */
            active: boolean;
        }

        /**
         * Media query expression descriptor.
         */
        export interface MediaQueryExpression {
            /**
             * Media query expression value.
             */
            value: number;
            /**
             * Media query expression units.
             */
            unit: string;
            /**
             * Media query expression feature.
             */
            feature: string;
            /**
             * The associated range of the value text in the enclosing stylesheet (if available).
             */
            valueRange?: SourceRange;
            /**
             * Computed length of media query expression (if applicable).
             */
            computedLength?: number;
        }

        /**
         * CSS container query rule descriptor.
         */
        export interface CSSContainerQuery {
            /**
             * Container query text.
             */
            text: string;
            /**
             * The associated rule header range in the enclosing stylesheet (if
             * available).
             */
            range?: SourceRange;
            /**
             * Identifier of the stylesheet containing this object (if exists).
             */
            styleSheetId?: StyleSheetId;
            /**
             * Optional name for the container.
             */
            name?: string;
            /**
             * Optional physical axes queried for the container.
             */
            physicalAxes?: DOM.PhysicalAxes;
            /**
             * Optional logical axes queried for the container.
             */
            logicalAxes?: DOM.LogicalAxes;
        }

        /**
         * CSS Supports at-rule descriptor.
         */
        export interface CSSSupports {
            /**
             * Supports rule text.
             */
            text: string;
            /**
             * Whether the supports condition is satisfied.
             */
            active: boolean;
            /**
             * The associated rule header range in the enclosing stylesheet (if
             * available).
             */
            range?: SourceRange;
            /**
             * Identifier of the stylesheet containing this object (if exists).
             */
            styleSheetId?: StyleSheetId;
        }

        /**
         * CSS Scope at-rule descriptor.
         */
        export interface CSSScope {
            /**
             * Scope rule text.
             */
            text: string;
            /**
             * The associated rule header range in the enclosing stylesheet (if
             * available).
             */
            range?: SourceRange;
            /**
             * Identifier of the stylesheet containing this object (if exists).
             */
            styleSheetId?: StyleSheetId;
        }

        /**
         * CSS Layer at-rule descriptor.
         */
        export interface CSSLayer {
            /**
             * Layer name.
             */
            text: string;
            /**
             * The associated rule header range in the enclosing stylesheet (if
             * available).
             */
            range?: SourceRange;
            /**
             * Identifier of the stylesheet containing this object (if exists).
             */
            styleSheetId?: StyleSheetId;
        }

        /**
         * CSS Layer data.
         */
        export interface CSSLayerData {
            /**
             * Layer name.
             */
            name: string;
            /**
             * Direct sub-layers
             */
            subLayers?: CSSLayerData[];
            /**
             * Layer order. The order determines the order of the layer in the cascade order.
             * A higher number has higher priority in the cascade order.
             */
            order: number;
        }

        /**
         * Information about amount of glyphs that were rendered with given font.
         */
        export interface PlatformFontUsage {
            /**
             * Font's family name reported by platform.
             */
            familyName: string;
            /**
             * Font's PostScript name reported by platform.
             */
            postScriptName: string;
            /**
             * Indicates if the font was downloaded or resolved locally.
             */
            isCustomFont: boolean;
            /**
             * Amount of glyphs that were rendered with this font.
             */
            glyphCount: number;
        }

        /**
         * Information about font variation axes for variable fonts
         */
        export interface FontVariationAxis {
            /**
             * The font-variation-setting tag (a.k.a. "axis tag").
             */
            tag: string;
            /**
             * Human-readable variation name in the default language (normally, "en").
             */
            name: string;
            /**
             * The minimum value (inclusive) the font supports for this tag.
             */
            minValue: number;
            /**
             * The maximum value (inclusive) the font supports for this tag.
             */
            maxValue: number;
            /**
             * The default value.
             */
            defaultValue: number;
        }

        /**
         * Properties of a web font: https://www.w3.org/TR/2008/REC-CSS2-20080411/fonts.html#font-descriptions
         * and additional information such as platformFontFamily and fontVariationAxes.
         */
        export interface FontFace {
            /**
             * The font-family.
             */
            fontFamily: string;
            /**
             * The font-style.
             */
            fontStyle: string;
            /**
             * The font-variant.
             */
            fontVariant: string;
            /**
             * The font-weight.
             */
            fontWeight: string;
            /**
             * The font-stretch.
             */
            fontStretch: string;
            /**
             * The font-display.
             */
            fontDisplay: string;
            /**
             * The unicode-range.
             */
            unicodeRange: string;
            /**
             * The src.
             */
            src: string;
            /**
             * The resolved platform font family
             */
            platformFontFamily: string;
            /**
             * Available variation settings (a.k.a. "axes").
             */
            fontVariationAxes?: FontVariationAxis[];
        }

        /**
         * CSS try rule representation.
         */
        export interface CSSTryRule {
            /**
             * The css style sheet identifier (absent for user agent stylesheet and user-specified
             * stylesheet rules) this rule came from.
             */
            styleSheetId?: StyleSheetId;
            /**
             * Parent stylesheet's origin.
             */
            origin: StyleSheetOrigin;
            /**
             * Associated style declaration.
             */
            style: CSSStyle;
        }

        /**
         * CSS position-fallback rule representation.
         */
        export interface CSSPositionFallbackRule {
            name: Value;
            /**
             * List of keyframes.
             */
            tryRules: CSSTryRule[];
        }

        /**
         * CSS @position-try rule representation.
         */
        export interface CSSPositionTryRule {
            /**
             * The prelude dashed-ident name
             */
            name: Value;
            /**
             * The css style sheet identifier (absent for user agent stylesheet and user-specified
             * stylesheet rules) this rule came from.
             */
            styleSheetId?: StyleSheetId;
            /**
             * Parent stylesheet's origin.
             */
            origin: StyleSheetOrigin;
            /**
             * Associated style declaration.
             */
            style: CSSStyle;
        }

        /**
         * CSS keyframes rule representation.
         */
        export interface CSSKeyframesRule {
            /**
             * Animation name.
             */
            animationName: Value;
            /**
             * List of keyframes.
             */
            keyframes: CSSKeyframeRule[];
        }

        /**
         * Representation of a custom property registration through CSS.registerProperty
         */
        export interface CSSPropertyRegistration {
            propertyName: string;
            initialValue?: Value;
            inherits: boolean;
            syntax: string;
        }

        /**
         * CSS font-palette-values rule representation.
         */
        export interface CSSFontPaletteValuesRule {
            /**
             * The css style sheet identifier (absent for user agent stylesheet and user-specified
             * stylesheet rules) this rule came from.
             */
            styleSheetId?: StyleSheetId;
            /**
             * Parent stylesheet's origin.
             */
            origin: StyleSheetOrigin;
            /**
             * Associated font palette name.
             */
            fontPaletteName: Value;
            /**
             * Associated style declaration.
             */
            style: CSSStyle;
        }

        /**
         * CSS property at-rule representation.
         */
        export interface CSSPropertyRule {
            /**
             * The css style sheet identifier (absent for user agent stylesheet and user-specified
             * stylesheet rules) this rule came from.
             */
            styleSheetId?: StyleSheetId;
            /**
             * Parent stylesheet's origin.
             */
            origin: StyleSheetOrigin;
            /**
             * Associated property name.
             */
            propertyName: Value;
            /**
             * Associated style declaration.
             */
            style: CSSStyle;
        }

        /**
         * CSS keyframe rule representation.
         */
        export interface CSSKeyframeRule {
            /**
             * The css style sheet identifier (absent for user agent stylesheet and user-specified
             * stylesheet rules) this rule came from.
             */
            styleSheetId?: StyleSheetId;
            /**
             * Parent stylesheet's origin.
             */
            origin: StyleSheetOrigin;
            /**
             * Associated key text.
             */
            keyText: Value;
            /**
             * Associated style declaration.
             */
            style: CSSStyle;
        }

        /**
         * A descriptor of operation to mutate style declaration text.
         */
        export interface StyleDeclarationEdit {
            /**
             * The css style sheet identifier.
             */
            styleSheetId: StyleSheetId;
            /**
             * The range of the style text in the enclosing stylesheet.
             */
            range: SourceRange;
            /**
             * New style text.
             */
            text: string;
        }

        export interface AddRuleRequest {
            /**
             * The css style sheet identifier where a new rule should be inserted.
             */
            styleSheetId: StyleSheetId;
            /**
             * The text of a new rule.
             */
            ruleText: string;
            /**
             * Text position of a new rule in the target style sheet.
             */
            location: SourceRange;
            /**
             * NodeId for the DOM node in whose context custom property declarations for registered properties should be
             * validated. If omitted, declarations in the new rule text can only be validated statically, which may produce
             * incorrect results if the declaration contains a var() for example.
             */
            nodeForPropertySyntaxValidation?: DOM.NodeId;
        }

        export interface AddRuleResponse {
            /**
             * The newly created rule.
             */
            rule: CSSRule;
        }

        export interface CollectClassNamesRequest {
            styleSheetId: StyleSheetId;
        }

        export interface CollectClassNamesResponse {
            /**
             * Class name list.
             */
            classNames: string[];
        }

        export interface CreateStyleSheetRequest {
            /**
             * Identifier of the frame where "via-inspector" stylesheet should be created.
             */
            frameId: Page.FrameId;
        }

        export interface CreateStyleSheetResponse {
            /**
             * Identifier of the created "via-inspector" stylesheet.
             */
            styleSheetId: StyleSheetId;
        }

        export interface ForcePseudoStateRequest {
            /**
             * The element id for which to force the pseudo state.
             */
            nodeId: DOM.NodeId;
            /**
             * Element pseudo classes to force when computing the element's style.
             */
            forcedPseudoClasses: string[];
        }

        export interface GetBackgroundColorsRequest {
            /**
             * Id of the node to get background colors for.
             */
            nodeId: DOM.NodeId;
        }

        export interface GetBackgroundColorsResponse {
            /**
             * The range of background colors behind this element, if it contains any visible text. If no
             * visible text is present, this will be undefined. In the case of a flat background color,
             * this will consist of simply that color. In the case of a gradient, this will consist of each
             * of the color stops. For anything more complicated, this will be an empty array. Images will
             * be ignored (as if the image had failed to load).
             */
            backgroundColors?: string[];
            /**
             * The computed font size for this node, as a CSS computed value string (e.g. '12px').
             */
            computedFontSize?: string;
            /**
             * The computed font weight for this node, as a CSS computed value string (e.g. 'normal' or
             * '100').
             */
            computedFontWeight?: string;
        }

        export interface GetComputedStyleForNodeRequest {
            nodeId: DOM.NodeId;
        }

        export interface GetComputedStyleForNodeResponse {
            /**
             * Computed style for the specified DOM node.
             */
            computedStyle: CSSComputedStyleProperty[];
        }

        export interface GetInlineStylesForNodeRequest {
            nodeId: DOM.NodeId;
        }

        export interface GetInlineStylesForNodeResponse {
            /**
             * Inline style for the specified DOM node.
             */
            inlineStyle?: CSSStyle;
            /**
             * Attribute-defined element style (e.g. resulting from "width=20 height=100%").
             */
            attributesStyle?: CSSStyle;
        }

        export interface GetMatchedStylesForNodeRequest {
            nodeId: DOM.NodeId;
        }

        export interface GetMatchedStylesForNodeResponse {
            /**
             * Inline style for the specified DOM node.
             */
            inlineStyle?: CSSStyle;
            /**
             * Attribute-defined element style (e.g. resulting from "width=20 height=100%").
             */
            attributesStyle?: CSSStyle;
            /**
             * CSS rules matching this node, from all applicable stylesheets.
             */
            matchedCSSRules?: RuleMatch[];
            /**
             * Pseudo style matches for this node.
             */
            pseudoElements?: PseudoElementMatches[];
            /**
             * A chain of inherited styles (from the immediate node parent up to the DOM tree root).
             */
            inherited?: InheritedStyleEntry[];
            /**
             * A chain of inherited pseudo element styles (from the immediate node parent up to the DOM tree root).
             */
            inheritedPseudoElements?: InheritedPseudoElementMatches[];
            /**
             * A list of CSS keyframed animations matching this node.
             */
            cssKeyframesRules?: CSSKeyframesRule[];
            /**
             * A list of CSS position fallbacks matching this node.
             */
            cssPositionFallbackRules?: CSSPositionFallbackRule[];
            /**
             * A list of CSS @position-try rules matching this node, based on the position-try-options property.
             */
            cssPositionTryRules?: CSSPositionTryRule[];
            /**
             * A list of CSS at-property rules matching this node.
             */
            cssPropertyRules?: CSSPropertyRule[];
            /**
             * A list of CSS property registrations matching this node.
             */
            cssPropertyRegistrations?: CSSPropertyRegistration[];
            /**
             * A font-palette-values rule matching this node.
             */
            cssFontPaletteValuesRule?: CSSFontPaletteValuesRule;
            /**
             * Id of the first parent element that does not have display: contents.
             */
            parentLayoutNodeId?: DOM.NodeId;
        }

        export interface GetMediaQueriesResponse {
            medias: CSSMedia[];
        }

        export interface GetPlatformFontsForNodeRequest {
            nodeId: DOM.NodeId;
        }

        export interface GetPlatformFontsForNodeResponse {
            /**
             * Usage statistics for every employed platform font.
             */
            fonts: PlatformFontUsage[];
        }

        export interface GetStyleSheetTextRequest {
            styleSheetId: StyleSheetId;
        }

        export interface GetStyleSheetTextResponse {
            /**
             * The stylesheet text.
             */
            text: string;
        }

        export interface GetLayersForNodeRequest {
            nodeId: DOM.NodeId;
        }

        export interface GetLayersForNodeResponse {
            rootLayer: CSSLayerData;
        }

        export interface GetLocationForSelectorRequest {
            styleSheetId: StyleSheetId;
            selectorText: string;
        }

        export interface GetLocationForSelectorResponse {
            ranges: SourceRange[];
        }

        export interface TrackComputedStyleUpdatesRequest {
            propertiesToTrack: CSSComputedStyleProperty[];
        }

        export interface TakeComputedStyleUpdatesResponse {
            /**
             * The list of node Ids that have their tracked computed styles updated.
             */
            nodeIds: DOM.NodeId[];
        }

        export interface SetEffectivePropertyValueForNodeRequest {
            /**
             * The element id for which to set property.
             */
            nodeId: DOM.NodeId;
            propertyName: string;
            value: string;
        }

        export interface SetPropertyRulePropertyNameRequest {
            styleSheetId: StyleSheetId;
            range: SourceRange;
            propertyName: string;
        }

        export interface SetPropertyRulePropertyNameResponse {
            /**
             * The resulting key text after modification.
             */
            propertyName: Value;
        }

        export interface SetKeyframeKeyRequest {
            styleSheetId: StyleSheetId;
            range: SourceRange;
            keyText: string;
        }

        export interface SetKeyframeKeyResponse {
            /**
             * The resulting key text after modification.
             */
            keyText: Value;
        }

        export interface SetMediaTextRequest {
            styleSheetId: StyleSheetId;
            range: SourceRange;
            text: string;
        }

        export interface SetMediaTextResponse {
            /**
             * The resulting CSS media rule after modification.
             */
            media: CSSMedia;
        }

        export interface SetContainerQueryTextRequest {
            styleSheetId: StyleSheetId;
            range: SourceRange;
            text: string;
        }

        export interface SetContainerQueryTextResponse {
            /**
             * The resulting CSS container query rule after modification.
             */
            containerQuery: CSSContainerQuery;
        }

        export interface SetSupportsTextRequest {
            styleSheetId: StyleSheetId;
            range: SourceRange;
            text: string;
        }

        export interface SetSupportsTextResponse {
            /**
             * The resulting CSS Supports rule after modification.
             */
            supports: CSSSupports;
        }

        export interface SetScopeTextRequest {
            styleSheetId: StyleSheetId;
            range: SourceRange;
            text: string;
        }

        export interface SetScopeTextResponse {
            /**
             * The resulting CSS Scope rule after modification.
             */
            scope: CSSScope;
        }

        export interface SetRuleSelectorRequest {
            styleSheetId: StyleSheetId;
            range: SourceRange;
            selector: string;
        }

        export interface SetRuleSelectorResponse {
            /**
             * The resulting selector list after modification.
             */
            selectorList: SelectorList;
        }

        export interface SetStyleSheetTextRequest {
            styleSheetId: StyleSheetId;
            text: string;
        }

        export interface SetStyleSheetTextResponse {
            /**
             * URL of source map associated with script (if any).
             */
            sourceMapURL?: string;
        }

        export interface SetStyleTextsRequest {
            edits: StyleDeclarationEdit[];
            /**
             * NodeId for the DOM node in whose context custom property declarations for registered properties should be
             * validated. If omitted, declarations in the new rule text can only be validated statically, which may produce
             * incorrect results if the declaration contains a var() for example.
             */
            nodeForPropertySyntaxValidation?: DOM.NodeId;
        }

        export interface SetStyleTextsResponse {
            /**
             * The resulting styles after modification.
             */
            styles: CSSStyle[];
        }

        export interface StopRuleUsageTrackingResponse {
            ruleUsage: RuleUsage[];
        }

        export interface TakeCoverageDeltaResponse {
            coverage: RuleUsage[];
            /**
             * Monotonically increasing time, in seconds.
             */
            timestamp: number;
        }

        export interface SetLocalFontsEnabledRequest {
            /**
             * Whether rendering of local fonts is enabled.
             */
            enabled: boolean;
        }

        /**
         * Fires whenever a web font is updated.  A non-empty font parameter indicates a successfully loaded
         * web font.
         */
        export interface FontsUpdatedEvent {
            /**
             * The web font that has loaded.
             */
            font?: FontFace;
        }

        /**
         * Fired whenever an active document stylesheet is added.
         */
        export interface StyleSheetAddedEvent {
            /**
             * Added stylesheet metainfo.
             */
            header: CSSStyleSheetHeader;
        }

        /**
         * Fired whenever a stylesheet is changed as a result of the client operation.
         */
        export interface StyleSheetChangedEvent {
            styleSheetId: StyleSheetId;
        }

        /**
         * Fired whenever an active document stylesheet is removed.
         */
        export interface StyleSheetRemovedEvent {
            /**
             * Identifier of the removed stylesheet.
             */
            styleSheetId: StyleSheetId;
        }
    }

    export namespace CacheStorage {

        /**
         * Unique identifier of the Cache object.
         */
        export type CacheId = string;

        /**
         * type of HTTP response cached
         */
        export type CachedResponseType = ('basic' | 'cors' | 'default' | 'error' | 'opaqueResponse' | 'opaqueRedirect');

        /**
         * Data entry.
         */
        export interface DataEntry {
            /**
             * Request URL.
             */
            requestURL: string;
            /**
             * Request method.
             */
            requestMethod: string;
            /**
             * Request headers
             */
            requestHeaders: Header[];
            /**
             * Number of seconds since epoch.
             */
            responseTime: number;
            /**
             * HTTP response status code.
             */
            responseStatus: integer;
            /**
             * HTTP response status text.
             */
            responseStatusText: string;
            /**
             * HTTP response type
             */
            responseType: CachedResponseType;
            /**
             * Response headers
             */
            responseHeaders: Header[];
        }

        /**
         * Cache identifier.
         */
        export interface Cache {
            /**
             * An opaque unique id of the cache.
             */
            cacheId: CacheId;
            /**
             * Security origin of the cache.
             */
            securityOrigin: string;
            /**
             * Storage key of the cache.
             */
            storageKey: string;
            /**
             * Storage bucket of the cache.
             */
            storageBucket?: Storage.StorageBucket;
            /**
             * The name of the cache.
             */
            cacheName: string;
        }

        export interface Header {
            name: string;
            value: string;
        }

        /**
         * Cached response
         */
        export interface CachedResponse {
            /**
             * Entry content, base64-encoded. (Encoded as a base64 string when passed over JSON)
             */
            body: string;
        }

        export interface DeleteCacheRequest {
            /**
             * Id of cache for deletion.
             */
            cacheId: CacheId;
        }

        export interface DeleteEntryRequest {
            /**
             * Id of cache where the entry will be deleted.
             */
            cacheId: CacheId;
            /**
             * URL spec of the request.
             */
            request: string;
        }

        export interface RequestCacheNamesRequest {
            /**
             * At least and at most one of securityOrigin, storageKey, storageBucket must be specified.
             * Security origin.
             */
            securityOrigin?: string;
            /**
             * Storage key.
             */
            storageKey?: string;
            /**
             * Storage bucket. If not specified, it uses the default bucket.
             */
            storageBucket?: Storage.StorageBucket;
        }

        export interface RequestCacheNamesResponse {
            /**
             * Caches for the security origin.
             */
            caches: Cache[];
        }

        export interface RequestCachedResponseRequest {
            /**
             * Id of cache that contains the entry.
             */
            cacheId: CacheId;
            /**
             * URL spec of the request.
             */
            requestURL: string;
            /**
             * headers of the request.
             */
            requestHeaders: Header[];
        }

        export interface RequestCachedResponseResponse {
            /**
             * Response read from the cache.
             */
            response: CachedResponse;
        }

        export interface RequestEntriesRequest {
            /**
             * ID of cache to get entries from.
             */
            cacheId: CacheId;
            /**
             * Number of records to skip.
             */
            skipCount?: integer;
            /**
             * Number of records to fetch.
             */
            pageSize?: integer;
            /**
             * If present, only return the entries containing this substring in the path
             */
            pathFilter?: string;
        }

        export interface RequestEntriesResponse {
            /**
             * Array of object store data entries.
             */
            cacheDataEntries: DataEntry[];
            /**
             * Count of returned entries from this storage. If pathFilter is empty, it
             * is the count of all entries from this storage.
             */
            returnCount: number;
        }
    }

    /**
     * A domain for interacting with Cast, Presentation API, and Remote Playback API
     * functionalities.
     */
    export namespace Cast {

        export interface Sink {
            name: string;
            id: string;
            /**
             * Text describing the current session. Present only if there is an active
             * session on the sink.
             */
            session?: string;
        }

        export interface EnableRequest {
            presentationUrl?: string;
        }

        export interface SetSinkToUseRequest {
            sinkName: string;
        }

        export interface StartDesktopMirroringRequest {
            sinkName: string;
        }

        export interface StartTabMirroringRequest {
            sinkName: string;
        }

        export interface StopCastingRequest {
            sinkName: string;
        }

        /**
         * This is fired whenever the list of available sinks changes. A sink is a
         * device or a software surface that you can cast to.
         */
        export interface SinksUpdatedEvent {
            sinks: Sink[];
        }

        /**
         * This is fired whenever the outstanding issue/error message changes.
         * |issueMessage| is empty if there is no issue.
         */
        export interface IssueUpdatedEvent {
            issueMessage: string;
        }
    }

    /**
     * This domain exposes DOM read/write operations. Each DOM Node is represented with its mirror object
     * that has an `id`. This `id` can be used to get additional information on the Node, resolve it into
     * the JavaScript object wrapper, etc. It is important that client receives DOM events only for the
     * nodes that are known to the client. Backend keeps track of the nodes that were sent to the client
     * and never sends the same node twice. It is client's responsibility to collect information about
     * the nodes that were sent to the client. Note that `iframe` owner elements will return
     * corresponding document elements as their child nodes.
     */
    export namespace DOM {

        /**
         * Unique DOM node identifier.
         */
        export type NodeId = integer;

        /**
         * Unique DOM node identifier used to reference a node that may not have been pushed to the
         * front-end.
         */
        export type BackendNodeId = integer;

        /**
         * Backend node with a friendly name.
         */
        export interface BackendNode {
            /**
             * `Node`'s nodeType.
             */
            nodeType: integer;
            /**
             * `Node`'s nodeName.
             */
            nodeName: string;
            backendNodeId: BackendNodeId;
        }

        /**
         * Pseudo element type.
         */
        export type PseudoType = ('first-line' | 'first-letter' | 'before' | 'after' | 'marker' | 'backdrop' | 'selection' | 'target-text' | 'spelling-error' | 'grammar-error' | 'highlight' | 'first-line-inherited' | 'scroll-marker' | 'scroll-markers' | 'scrollbar' | 'scrollbar-thumb' | 'scrollbar-button' | 'scrollbar-track' | 'scrollbar-track-piece' | 'scrollbar-corner' | 'resizer' | 'input-list-button' | 'view-transition' | 'view-transition-group' | 'view-transition-image-pair' | 'view-transition-old' | 'view-transition-new');

        /**
         * Shadow root type.
         */
        export type ShadowRootType = ('user-agent' | 'open' | 'closed');

        /**
         * Document compatibility mode.
         */
        export type CompatibilityMode = ('QuirksMode' | 'LimitedQuirksMode' | 'NoQuirksMode');

        /**
         * ContainerSelector physical axes
         */
        export type PhysicalAxes = ('Horizontal' | 'Vertical' | 'Both');

        /**
         * ContainerSelector logical axes
         */
        export type LogicalAxes = ('Inline' | 'Block' | 'Both');

        /**
         * Physical scroll orientation
         */
        export type ScrollOrientation = ('horizontal' | 'vertical');

        /**
         * DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes.
         * DOMNode is a base node mirror type.
         */
        export interface Node {
            /**
             * Node identifier that is passed into the rest of the DOM messages as the `nodeId`. Backend
             * will only push node with given `id` once. It is aware of all requested nodes and will only
             * fire DOM events for nodes known to the client.
             */
            nodeId: NodeId;
            /**
             * The id of the parent node if any.
             */
            parentId?: NodeId;
            /**
             * The BackendNodeId for this node.
             */
            backendNodeId: BackendNodeId;
            /**
             * `Node`'s nodeType.
             */
            nodeType: integer;
            /**
             * `Node`'s nodeName.
             */
            nodeName: string;
            /**
             * `Node`'s localName.
             */
            localName: string;
            /**
             * `Node`'s nodeValue.
             */
            nodeValue: string;
            /**
             * Child count for `Container` nodes.
             */
            childNodeCount?: integer;
            /**
             * Child nodes of this node when requested with children.
             */
            children?: Node[];
            /**
             * Attributes of the `Element` node in the form of flat array `[name1, value1, name2, value2]`.
             */
            attributes?: string[];
            /**
             * Document URL that `Document` or `FrameOwner` node points to.
             */
            documentURL?: string;
            /**
             * Base URL that `Document` or `FrameOwner` node uses for URL completion.
             */
            baseURL?: string;
            /**
             * `DocumentType`'s publicId.
             */
            publicId?: string;
            /**
             * `DocumentType`'s systemId.
             */
            systemId?: string;
            /**
             * `DocumentType`'s internalSubset.
             */
            internalSubset?: string;
            /**
             * `Document`'s XML version in case of XML documents.
             */
            xmlVersion?: string;
            /**
             * `Attr`'s name.
             */
            name?: string;
            /**
             * `Attr`'s value.
             */
            value?: string;
            /**
             * Pseudo element type for this node.
             */
            pseudoType?: PseudoType;
            /**
             * Pseudo element identifier for this node. Only present if there is a
             * valid pseudoType.
             */
            pseudoIdentifier?: string;
            /**
             * Shadow root type.
             */
            shadowRootType?: ShadowRootType;
            /**
             * Frame ID for frame owner elements.
             */
            frameId?: Page.FrameId;
            /**
             * Content document for frame owner elements.
             */
            contentDocument?: Node;
            /**
             * Shadow root list for given element host.
             */
            shadowRoots?: Node[];
            /**
             * Content document fragment for template elements.
             */
            templateContent?: Node;
            /**
             * Pseudo elements associated with this node.
             */
            pseudoElements?: Node[];
            /**
             * Deprecated, as the HTML Imports API has been removed (crbug.com/937746).
             * This property used to return the imported document for the HTMLImport links.
             * The property is always undefined now.
             */
            importedDocument?: Node;
            /**
             * Distributed nodes for given insertion point.
             */
            distributedNodes?: BackendNode[];
            /**
             * Whether the node is SVG.
             */
            isSVG?: boolean;
            compatibilityMode?: CompatibilityMode;
            assignedSlot?: BackendNode;
        }

        /**
         * A structure holding an RGBA color.
         */
        export interface RGBA {
            /**
             * The red component, in the [0-255] range.
             */
            r: integer;
            /**
             * The green component, in the [0-255] range.
             */
            g: integer;
            /**
             * The blue component, in the [0-255] range.
             */
            b: integer;
            /**
             * The alpha component, in the [0-1] range (default: 1).
             */
            a?: number;
        }

        /**
         * An array of quad vertices, x immediately followed by y for each point, points clock-wise.
         */
        export type Quad = number[];

        /**
         * Box model.
         */
        export interface BoxModel {
            /**
             * Content box
             */
            content: Quad;
            /**
             * Padding box
             */
            padding: Quad;
            /**
             * Border box
             */
            border: Quad;
            /**
             * Margin box
             */
            margin: Quad;
            /**
             * Node width
             */
            width: integer;
            /**
             * Node height
             */
            height: integer;
            /**
             * Shape outside coordinates
             */
            shapeOutside?: ShapeOutsideInfo;
        }

        /**
         * CSS Shape Outside details.
         */
        export interface ShapeOutsideInfo {
            /**
             * Shape bounds
             */
            bounds: Quad;
            /**
             * Shape coordinate details
             */
            shape: any[];
            /**
             * Margin shape bounds
             */
            marginShape: any[];
        }

        /**
         * Rectangle.
         */
        export interface Rect {
            /**
             * X coordinate
             */
            x: number;
            /**
             * Y coordinate
             */
            y: number;
            /**
             * Rectangle width
             */
            width: number;
            /**
             * Rectangle height
             */
            height: number;
        }

        export interface CSSComputedStyleProperty {
            /**
             * Computed style property name.
             */
            name: string;
            /**
             * Computed style property value.
             */
            value: string;
        }

        export interface CollectClassNamesFromSubtreeRequest {
            /**
             * Id of the node to collect class names.
             */
            nodeId: NodeId;
        }

        export interface CollectClassNamesFromSubtreeResponse {
            /**
             * Class name list.
             */
            classNames: string[];
        }

        export interface CopyToRequest {
            /**
             * Id of the node to copy.
             */
            nodeId: NodeId;
            /**
             * Id of the element to drop the copy into.
             */
            targetNodeId: NodeId;
            /**
             * Drop the copy before this node (if absent, the copy becomes the last child of
             * `targetNodeId`).
             */
            insertBeforeNodeId?: NodeId;
        }

        export interface CopyToResponse {
            /**
             * Id of the node clone.
             */
            nodeId: NodeId;
        }

        export interface DescribeNodeRequest {
            /**
             * Identifier of the node.
             */
            nodeId?: NodeId;
            /**
             * Identifier of the backend node.
             */
            backendNodeId?: BackendNodeId;
            /**
             * JavaScript object id of the node wrapper.
             */
            objectId?: Runtime.RemoteObjectId;
            /**
             * The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
             * entire subtree or provide an integer larger than 0.
             */
            depth?: integer;
            /**
             * Whether or not iframes and shadow roots should be traversed when returning the subtree
             * (default is false).
             */
            pierce?: boolean;
        }

        export interface DescribeNodeResponse {
            /**
             * Node description.
             */
            node: Node;
        }

        export interface ScrollIntoViewIfNeededRequest {
            /**
             * Identifier of the node.
             */
            nodeId?: NodeId;
            /**
             * Identifier of the backend node.
             */
            backendNodeId?: BackendNodeId;
            /**
             * JavaScript object id of the node wrapper.
             */
            objectId?: Runtime.RemoteObjectId;
            /**
             * The rect to be scrolled into view, relative to the node's border box, in CSS pixels.
             * When omitted, center of the node will be used, similar to Element.scrollIntoView.
             */
            rect?: Rect;
        }

        export interface DiscardSearchResultsRequest {
            /**
             * Unique search session identifier.
             */
            searchId: string;
        }

        export const enum EnableRequestIncludeWhitespace {
            None = 'none',
            All = 'all',
        }

        export interface EnableRequest {
            /**
             * Whether to include whitespaces in the children array of returned Nodes. (EnableRequestIncludeWhitespace enum)
             */
            includeWhitespace?: ('none' | 'all');
        }

        export interface FocusRequest {
            /**
             * Identifier of the node.
             */
            nodeId?: NodeId;
            /**
             * Identifier of the backend node.
             */
            backendNodeId?: BackendNodeId;
            /**
             * JavaScript object id of the node wrapper.
             */
            objectId?: Runtime.RemoteObjectId;
        }

        export interface GetAttributesRequest {
            /**
             * Id of the node to retrieve attributes for.
             */
            nodeId: NodeId;
        }

        export interface GetAttributesResponse {
            /**
             * An interleaved array of node attribute names and values.
             */
            attributes: string[];
        }

        export interface GetBoxModelRequest {
            /**
             * Identifier of the node.
             */
            nodeId?: NodeId;
            /**
             * Identifier of the backend node.
             */
            backendNodeId?: BackendNodeId;
            /**
             * JavaScript object id of the node wrapper.
             */
            objectId?: Runtime.RemoteObjectId;
        }

        export interface GetBoxModelResponse {
            /**
             * Box model for the node.
             */
            model: BoxModel;
        }

        export interface GetContentQuadsRequest {
            /**
             * Identifier of the node.
             */
            nodeId?: NodeId;
            /**
             * Identifier of the backend node.
             */
            backendNodeId?: BackendNodeId;
            /**
             * JavaScript object id of the node wrapper.
             */
            objectId?: Runtime.RemoteObjectId;
        }

        export interface GetContentQuadsResponse {
            /**
             * Quads that describe node layout relative to viewport.
             */
            quads: Quad[];
        }

        export interface GetDocumentRequest {
            /**
             * The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
             * entire subtree or provide an integer larger than 0.
             */
            depth?: integer;
            /**
             * Whether or not iframes and shadow roots should be traversed when returning the subtree
             * (default is false).
             */
            pierce?: boolean;
        }

        export interface GetDocumentResponse {
            /**
             * Resulting node.
             */
            root: Node;
        }

        export interface GetFlattenedDocumentRequest {
            /**
             * The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
             * entire subtree or provide an integer larger than 0.
             */
            depth?: integer;
            /**
             * Whether or not iframes and shadow roots should be traversed when returning the subtree
             * (default is false).
             */
            pierce?: boolean;
        }

        export interface GetFlattenedDocumentResponse {
            /**
             * Resulting node.
             */
            nodes: Node[];
        }

        export interface GetNodesForSubtreeByStyleRequest {
            /**
             * Node ID pointing to the root of a subtree.
             */
            nodeId: NodeId;
            /**
             * The style to filter nodes by (includes nodes if any of properties matches).
             */
            computedStyles: CSSComputedStyleProperty[];
            /**
             * Whether or not iframes and shadow roots in the same target should be traversed when returning the
             * results (default is false).
             */
            pierce?: boolean;
        }

        export interface GetNodesForSubtreeByStyleResponse {
            /**
             * Resulting nodes.
             */
            nodeIds: NodeId[];
        }

        export interface GetNodeForLocationRequest {
            /**
             * X coordinate.
             */
            x: integer;
            /**
             * Y coordinate.
             */
            y: integer;
            /**
             * False to skip to the nearest non-UA shadow root ancestor (default: false).
             */
            includeUserAgentShadowDOM?: boolean;
            /**
             * Whether to ignore pointer-events: none on elements and hit test them.
             */
            ignorePointerEventsNone?: boolean;
        }

        export interface GetNodeForLocationResponse {
            /**
             * Resulting node.
             */
            backendNodeId: BackendNodeId;
            /**
             * Frame this node belongs to.
             */
            frameId: Page.FrameId;
            /**
             * Id of the node at given coordinates, only when enabled and requested document.
             */
            nodeId?: NodeId;
        }

        export interface GetOuterHTMLRequest {
            /**
             * Identifier of the node.
             */
            nodeId?: NodeId;
            /**
             * Identifier of the backend node.
             */
            backendNodeId?: BackendNodeId;
            /**
             * JavaScript object id of the node wrapper.
             */
            objectId?: Runtime.RemoteObjectId;
        }

        export interface GetOuterHTMLResponse {
            /**
             * Outer HTML markup.
             */
            outerHTML: string;
        }

        export interface GetRelayoutBoundaryRequest {
            /**
             * Id of the node.
             */
            nodeId: NodeId;
        }

        export interface GetRelayoutBoundaryResponse {
            /**
             * Relayout boundary node id for the given node.
             */
            nodeId: NodeId;
        }

        export interface GetSearchResultsRequest {
            /**
             * Unique search session identifier.
             */
            searchId: string;
            /**
             * Start index of the search result to be returned.
             */
            fromIndex: integer;
            /**
             * End index of the search result to be returned.
             */
            toIndex: integer;
        }

        export interface GetSearchResultsResponse {
            /**
             * Ids of the search result nodes.
             */
            nodeIds: NodeId[];
        }

        export interface MoveToRequest {
            /**
             * Id of the node to move.
             */
            nodeId: NodeId;
            /**
             * Id of the element to drop the moved node into.
             */
            targetNodeId: NodeId;
            /**
             * Drop node before this one (if absent, the moved node becomes the last child of
             * `targetNodeId`).
             */
            insertBeforeNodeId?: NodeId;
        }

        export interface MoveToResponse {
            /**
             * New id of the moved node.
             */
            nodeId: NodeId;
        }

        export interface PerformSearchRequest {
            /**
             * Plain text or query selector or XPath search query.
             */
            query: string;
            /**
             * True to search in user agent shadow DOM.
             */
            includeUserAgentShadowDOM?: boolean;
        }

        export interface PerformSearchResponse {
            /**
             * Unique search session identifier.
             */
            searchId: string;
            /**
             * Number of search results.
             */
            resultCount: integer;
        }

        export interface PushNodeByPathToFrontendRequest {
            /**
             * Path to node in the proprietary format.
             */
            path: string;
        }

        export interface PushNodeByPathToFrontendResponse {
            /**
             * Id of the node for given path.
             */
            nodeId: NodeId;
        }

        export interface PushNodesByBackendIdsToFrontendRequest {
            /**
             * The array of backend node ids.
             */
            backendNodeIds: BackendNodeId[];
        }

        export interface PushNodesByBackendIdsToFrontendResponse {
            /**
             * The array of ids of pushed nodes that correspond to the backend ids specified in
             * backendNodeIds.
             */
            nodeIds: NodeId[];
        }

        export interface QuerySelectorRequest {
            /**
             * Id of the node to query upon.
             */
            nodeId: NodeId;
            /**
             * Selector string.
             */
            selector: string;
        }

        export interface QuerySelectorResponse {
            /**
             * Query selector result.
             */
            nodeId: NodeId;
        }

        export interface QuerySelectorAllRequest {
            /**
             * Id of the node to query upon.
             */
            nodeId: NodeId;
            /**
             * Selector string.
             */
            selector: string;
        }

        export interface QuerySelectorAllResponse {
            /**
             * Query selector result.
             */
            nodeIds: NodeId[];
        }

        export interface GetTopLayerElementsResponse {
            /**
             * NodeIds of top layer elements
             */
            nodeIds: NodeId[];
        }

        export interface RemoveAttributeRequest {
            /**
             * Id of the element to remove attribute from.
             */
            nodeId: NodeId;
            /**
             * Name of the attribute to remove.
             */
            name: string;
        }

        export interface RemoveNodeRequest {
            /**
             * Id of the node to remove.
             */
            nodeId: NodeId;
        }

        export interface RequestChildNodesRequest {
            /**
             * Id of the node to get children for.
             */
            nodeId: NodeId;
            /**
             * The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
             * entire subtree or provide an integer larger than 0.
             */
            depth?: integer;
            /**
             * Whether or not iframes and shadow roots should be traversed when returning the sub-tree
             * (default is false).
             */
            pierce?: boolean;
        }

        export interface RequestNodeRequest {
            /**
             * JavaScript object id to convert into node.
             */
            objectId: Runtime.RemoteObjectId;
        }

        export interface RequestNodeResponse {
            /**
             * Node id for given object.
             */
            nodeId: NodeId;
        }

        export interface ResolveNodeRequest {
            /**
             * Id of the node to resolve.
             */
            nodeId?: NodeId;
            /**
             * Backend identifier of the node to resolve.
             */
            backendNodeId?: DOM.BackendNodeId;
            /**
             * Symbolic group name that can be used to release multiple objects.
             */
            objectGroup?: string;
            /**
             * Execution context in which to resolve the node.
             */
            executionContextId?: Runtime.ExecutionContextId;
        }

        export interface ResolveNodeResponse {
            /**
             * JavaScript object wrapper for given node.
             */
            object: Runtime.RemoteObject;
        }

        export interface SetAttributeValueRequest {
            /**
             * Id of the element to set attribute for.
             */
            nodeId: NodeId;
            /**
             * Attribute name.
             */
            name: string;
            /**
             * Attribute value.
             */
            value: string;
        }

        export interface SetAttributesAsTextRequest {
            /**
             * Id of the element to set attributes for.
             */
            nodeId: NodeId;
            /**
             * Text with a number of attributes. Will parse this text using HTML parser.
             */
            text: string;
            /**
             * Attribute name to replace with new attributes derived from text in case text parsed
             * successfully.
             */
            name?: string;
        }

        export interface SetFileInputFilesRequest {
            /**
             * Array of file paths to set.
             */
            files: string[];
            /**
             * Identifier of the node.
             */
            nodeId?: NodeId;
            /**
             * Identifier of the backend node.
             */
            backendNodeId?: BackendNodeId;
            /**
             * JavaScript object id of the node wrapper.
             */
            objectId?: Runtime.RemoteObjectId;
        }

        export interface SetNodeStackTracesEnabledRequest {
            /**
             * Enable or disable.
             */
            enable: boolean;
        }

        export interface GetNodeStackTracesRequest {
            /**
             * Id of the node to get stack traces for.
             */
            nodeId: NodeId;
        }

        export interface GetNodeStackTracesResponse {
            /**
             * Creation stack trace, if available.
             */
            creation?: Runtime.StackTrace;
        }

        export interface GetFileInfoRequest {
            /**
             * JavaScript object id of the node wrapper.
             */
            objectId: Runtime.RemoteObjectId;
        }

        export interface GetFileInfoResponse {
            path: string;
        }

        export interface SetInspectedNodeRequest {
            /**
             * DOM node id to be accessible by means of $x command line API.
             */
            nodeId: NodeId;
        }

        export interface SetNodeNameRequest {
            /**
             * Id of the node to set name for.
             */
            nodeId: NodeId;
            /**
             * New node's name.
             */
            name: string;
        }

        export interface SetNodeNameResponse {
            /**
             * New node's id.
             */
            nodeId: NodeId;
        }

        export interface SetNodeValueRequest {
            /**
             * Id of the node to set value for.
             */
            nodeId: NodeId;
            /**
             * New node's value.
             */
            value: string;
        }

        export interface SetOuterHTMLRequest {
            /**
             * Id of the node to set markup for.
             */
            nodeId: NodeId;
            /**
             * Outer HTML markup to set.
             */
            outerHTML: string;
        }

        export interface GetFrameOwnerRequest {
            frameId: Page.FrameId;
        }

        export interface GetFrameOwnerResponse {
            /**
             * Resulting node.
             */
            backendNodeId: BackendNodeId;
            /**
             * Id of the node at given coordinates, only when enabled and requested document.
             */
            nodeId?: NodeId;
        }

        export interface GetContainerForNodeRequest {
            nodeId: NodeId;
            containerName?: string;
            physicalAxes?: PhysicalAxes;
            logicalAxes?: LogicalAxes;
        }

        export interface GetContainerForNodeResponse {
            /**
             * The container node for the given node, or null if not found.
             */
            nodeId?: NodeId;
        }

        export interface GetQueryingDescendantsForContainerRequest {
            /**
             * Id of the container node to find querying descendants from.
             */
            nodeId: NodeId;
        }

        export interface GetQueryingDescendantsForContainerResponse {
            /**
             * Descendant nodes with container queries against the given container.
             */
            nodeIds: NodeId[];
        }

        /**
         * Fired when `Element`'s attribute is modified.
         */
        export interface AttributeModifiedEvent {
            /**
             * Id of the node that has changed.
             */
            nodeId: NodeId;
            /**
             * Attribute name.
             */
            name: string;
            /**
             * Attribute value.
             */
            value: string;
        }

        /**
         * Fired when `Element`'s attribute is removed.
         */
        export interface AttributeRemovedEvent {
            /**
             * Id of the node that has changed.
             */
            nodeId: NodeId;
            /**
             * A ttribute name.
             */
            name: string;
        }

        /**
         * Mirrors `DOMCharacterDataModified` event.
         */
        export interface CharacterDataModifiedEvent {
            /**
             * Id of the node that has changed.
             */
            nodeId: NodeId;
            /**
             * New text value.
             */
            characterData: string;
        }

        /**
         * Fired when `Container`'s child node count has changed.
         */
        export interface ChildNodeCountUpdatedEvent {
            /**
             * Id of the node that has changed.
             */
            nodeId: NodeId;
            /**
             * New node count.
             */
            childNodeCount: integer;
        }

        /**
         * Mirrors `DOMNodeInserted` event.
         */
        export interface ChildNodeInsertedEvent {
            /**
             * Id of the node that has changed.
             */
            parentNodeId: NodeId;
            /**
             * Id of the previous sibling.
             */
            previousNodeId: NodeId;
            /**
             * Inserted node data.
             */
            node: Node;
        }

        /**
         * Mirrors `DOMNodeRemoved` event.
         */
        export interface ChildNodeRemovedEvent {
            /**
             * Parent id.
             */
            parentNodeId: NodeId;
            /**
             * Id of the node that has been removed.
             */
            nodeId: NodeId;
        }

        /**
         * Called when distribution is changed.
         */
        export interface DistributedNodesUpdatedEvent {
            /**
             * Insertion point where distributed nodes were updated.
             */
            insertionPointId: NodeId;
            /**
             * Distributed nodes for given insertion point.
             */
            distributedNodes: BackendNode[];
        }

        /**
         * Fired when `Element`'s inline style is modified via a CSS property modification.
         */
        export interface InlineStyleInvalidatedEvent {
            /**
             * Ids of the nodes for which the inline styles have been invalidated.
             */
            nodeIds: NodeId[];
        }

        /**
         * Called when a pseudo element is added to an element.
         */
        export interface PseudoElementAddedEvent {
            /**
             * Pseudo element's parent element id.
             */
            parentId: NodeId;
            /**
             * The added pseudo element.
             */
            pseudoElement: Node;
        }

        /**
         * Called when a pseudo element is removed from an element.
         */
        export interface PseudoElementRemovedEvent {
            /**
             * Pseudo element's parent element id.
             */
            parentId: NodeId;
            /**
             * The removed pseudo element id.
             */
            pseudoElementId: NodeId;
        }

        /**
         * Fired when backend wants to provide client with the missing DOM structure. This happens upon
         * most of the calls requesting node ids.
         */
        export interface SetChildNodesEvent {
            /**
             * Parent node id to populate with children.
             */
            parentId: NodeId;
            /**
             * Child nodes array.
             */
            nodes: Node[];
        }

        /**
         * Called when shadow root is popped from the element.
         */
        export interface ShadowRootPoppedEvent {
            /**
             * Host element id.
             */
            hostId: NodeId;
            /**
             * Shadow root id.
             */
            rootId: NodeId;
        }

        /**
         * Called when shadow root is pushed into the element.
         */
        export interface ShadowRootPushedEvent {
            /**
             * Host element id.
             */
            hostId: NodeId;
            /**
             * Shadow root.
             */
            root: Node;
        }
    }

    /**
     * DOM debugging allows setting breakpoints on particular DOM operations and events. JavaScript
     * execution will stop on these operations as if there was a regular breakpoint set.
     */
    export namespace DOMDebugger {

        /**
         * DOM breakpoint type.
         */
        export type DOMBreakpointType = ('subtree-modified' | 'attribute-modified' | 'node-removed');

        /**
         * CSP Violation type.
         */
        export type CSPViolationType = ('trustedtype-sink-violation' | 'trustedtype-policy-violation');

        /**
         * Object event listener.
         */
        export interface EventListener {
            /**
             * `EventListener`'s type.
             */
            type: string;
            /**
             * `EventListener`'s useCapture.
             */
            useCapture: boolean;
            /**
             * `EventListener`'s passive flag.
             */
            passive: boolean;
            /**
             * `EventListener`'s once flag.
             */
            once: boolean;
            /**
             * Script id of the handler code.
             */
            scriptId: Runtime.ScriptId;
            /**
             * Line number in the script (0-based).
             */
            lineNumber: integer;
            /**
             * Column number in the script (0-based).
             */
            columnNumber: integer;
            /**
             * Event handler function value.
             */
            handler?: Runtime.RemoteObject;
            /**
             * Event original handler function value.
             */
            originalHandler?: Runtime.RemoteObject;
            /**
             * Node the listener is added to (if any).
             */
            backendNodeId?: DOM.BackendNodeId;
        }

        export interface GetEventListenersRequest {
            /**
             * Identifier of the object to return listeners for.
             */
            objectId: Runtime.RemoteObjectId;
            /**
             * The maximum depth at which Node children should be retrieved, defaults to 1. Use -1 for the
             * entire subtree or provide an integer larger than 0.
             */
            depth?: integer;
            /**
             * Whether or not iframes and shadow roots should be traversed when returning the subtree
             * (default is false). Reports listeners for all contexts if pierce is enabled.
             */
            pierce?: boolean;
        }

        export interface GetEventListenersResponse {
            /**
             * Array of relevant listeners.
             */
            listeners: EventListener[];
        }

        export interface RemoveDOMBreakpointRequest {
            /**
             * Identifier of the node to remove breakpoint from.
             */
            nodeId: DOM.NodeId;
            /**
             * Type of the breakpoint to remove.
             */
            type: DOMBreakpointType;
        }

        export interface RemoveEventListenerBreakpointRequest {
            /**
             * Event name.
             */
            eventName: string;
            /**
             * EventTarget interface name.
             */
            targetName?: string;
        }

        export interface RemoveInstrumentationBreakpointRequest {
            /**
             * Instrumentation name to stop on.
             */
            eventName: string;
        }

        export interface RemoveXHRBreakpointRequest {
            /**
             * Resource URL substring.
             */
            url: string;
        }

        export interface SetBreakOnCSPViolationRequest {
            /**
             * CSP Violations to stop upon.
             */
            violationTypes: CSPViolationType[];
        }

        export interface SetDOMBreakpointRequest {
            /**
             * Identifier of the node to set breakpoint on.
             */
            nodeId: DOM.NodeId;
            /**
             * Type of the operation to stop upon.
             */
            type: DOMBreakpointType;
        }

        export interface SetEventListenerBreakpointRequest {
            /**
             * DOM Event name to stop on (any DOM event will do).
             */
            eventName: string;
            /**
             * EventTarget interface name to stop on. If equal to `"*"` or not provided, will stop on any
             * EventTarget.
             */
            targetName?: string;
        }

        export interface SetInstrumentationBreakpointRequest {
            /**
             * Instrumentation name to stop on.
             */
            eventName: string;
        }

        export interface SetXHRBreakpointRequest {
            /**
             * Resource URL substring. All XHRs having this substring in the URL will get stopped upon.
             */
            url: string;
        }
    }

    /**
     * EventBreakpoints permits setting JavaScript breakpoints on operations and events
     * occurring in native code invoked from JavaScript. Once breakpoint is hit, it is
     * reported through Debugger domain, similarly to regular breakpoints being hit.
     */
    export namespace EventBreakpoints {

        export interface SetInstrumentationBreakpointRequest {
            /**
             * Instrumentation name to stop on.
             */
            eventName: string;
        }

        export interface RemoveInstrumentationBreakpointRequest {
            /**
             * Instrumentation name to stop on.
             */
            eventName: string;
        }
    }

    /**
     * This domain facilitates obtaining document snapshots with DOM, layout, and style information.
     */
    export namespace DOMSnapshot {

        /**
         * A Node in the DOM tree.
         */
        export interface DOMNode {
            /**
             * `Node`'s nodeType.
             */
            nodeType: integer;
            /**
             * `Node`'s nodeName.
             */
            nodeName: string;
            /**
             * `Node`'s nodeValue.
             */
            nodeValue: string;
            /**
             * Only set for textarea elements, contains the text value.
             */
            textValue?: string;
            /**
             * Only set for input elements, contains the input's associated text value.
             */
            inputValue?: string;
            /**
             * Only set for radio and checkbox input elements, indicates if the element has been checked
             */
            inputChecked?: boolean;
            /**
             * Only set for option elements, indicates if the element has been selected
             */
            optionSelected?: boolean;
            /**
             * `Node`'s id, corresponds to DOM.Node.backendNodeId.
             */
            backendNodeId: DOM.BackendNodeId;
            /**
             * The indexes of the node's child nodes in the `domNodes` array returned by `getSnapshot`, if
             * any.
             */
            childNodeIndexes?: integer[];
            /**
             * Attributes of an `Element` node.
             */
            attributes?: NameValue[];
            /**
             * Indexes of pseudo elements associated with this node in the `domNodes` array returned by
             * `getSnapshot`, if any.
             */
            pseudoElementIndexes?: integer[];
            /**
             * The index of the node's related layout tree node in the `layoutTreeNodes` array returned by
             * `getSnapshot`, if any.
             */
            layoutNodeIndex?: integer;
            /**
             * Document URL that `Document` or `FrameOwner` node points to.
             */
            documentURL?: string;
            /**
             * Base URL that `Document` or `FrameOwner` node uses for URL completion.
             */
            baseURL?: string;
            /**
             * Only set for documents, contains the document's content language.
             */
            contentLanguage?: string;
            /**
             * Only set for documents, contains the document's character set encoding.
             */
            documentEncoding?: string;
            /**
             * `DocumentType` node's publicId.
             */
            publicId?: string;
            /**
             * `DocumentType` node's systemId.
             */
            systemId?: string;
            /**
             * Frame ID for frame owner elements and also for the document node.
             */
            frameId?: Page.FrameId;
            /**
             * The index of a frame owner element's content document in the `domNodes` array returned by
             * `getSnapshot`, if any.
             */
            contentDocumentIndex?: integer;
            /**
             * Type of a pseudo element node.
             */
            pseudoType?: DOM.PseudoType;
            /**
             * Shadow root type.
             */
            shadowRootType?: DOM.ShadowRootType;
            /**
             * Whether this DOM node responds to mouse clicks. This includes nodes that have had click
             * event listeners attached via JavaScript as well as anchor tags that naturally navigate when
             * clicked.
             */
            isClickable?: boolean;
            /**
             * Details of the node's event listeners, if any.
             */
            eventListeners?: DOMDebugger.EventListener[];
            /**
             * The selected url for nodes with a srcset attribute.
             */
            currentSourceURL?: string;
            /**
             * The url of the script (if any) that generates this node.
             */
            originURL?: string;
            /**
             * Scroll offsets, set when this node is a Document.
             */
            scrollOffsetX?: number;
            scrollOffsetY?: number;
        }

        /**
         * Details of post layout rendered text positions. The exact layout should not be regarded as
         * stable and may change between versions.
         */
        export interface InlineTextBox {
            /**
             * The bounding box in document coordinates. Note that scroll offset of the document is ignored.
             */
            boundingBox: DOM.Rect;
            /**
             * The starting index in characters, for this post layout textbox substring. Characters that
             * would be represented as a surrogate pair in UTF-16 have length 2.
             */
            startCharacterIndex: integer;
            /**
             * The number of characters in this post layout textbox substring. Characters that would be
             * represented as a surrogate pair in UTF-16 have length 2.
             */
            numCharacters: integer;
        }

        /**
         * Details of an element in the DOM tree with a LayoutObject.
         */
        export interface LayoutTreeNode {
            /**
             * The index of the related DOM node in the `domNodes` array returned by `getSnapshot`.
             */
            domNodeIndex: integer;
            /**
             * The bounding box in document coordinates. Note that scroll offset of the document is ignored.
             */
            boundingBox: DOM.Rect;
            /**
             * Contents of the LayoutText, if any.
             */
            layoutText?: string;
            /**
             * The post-layout inline text nodes, if any.
             */
            inlineTextNodes?: InlineTextBox[];
            /**
             * Index into the `computedStyles` array returned by `getSnapshot`.
             */
            styleIndex?: integer;
            /**
             * Global paint order index, which is determined by the stacking order of the nodes. Nodes
             * that are painted together will have the same index. Only provided if includePaintOrder in
             * getSnapshot was true.
             */
            paintOrder?: integer;
            /**
             * Set to true to indicate the element begins a new stacking context.
             */
            isStackingContext?: boolean;
        }

        /**
         * A subset of the full ComputedStyle as defined by the request whitelist.
         */
        export interface ComputedStyle {
            /**
             * Name/value pairs of computed style properties.
             */
            properties: NameValue[];
        }

        /**
         * A name/value pair.
         */
        export interface NameValue {
            /**
             * Attribute/property name.
             */
            name: string;
            /**
             * Attribute/property value.
             */
            value: string;
        }

        /**
         * Index of the string in the strings table.
         */
        export type StringIndex = integer;

        /**
         * Index of the string in the strings table.
         */
        export type ArrayOfStrings = StringIndex[];

        /**
         * Data that is only present on rare nodes.
         */
        export interface RareStringData {
            index: integer[];
            value: StringIndex[];
        }

        export interface RareBooleanData {
            index: integer[];
        }

        export interface RareIntegerData {
            index: integer[];
            value: integer[];
        }

        export type Rectangle = number[];

        /**
         * Document snapshot.
         */
        export interface DocumentSnapshot {
            /**
             * Document URL that `Document` or `FrameOwner` node points to.
             */
            documentURL: StringIndex;
            /**
             * Document title.
             */
            title: StringIndex;
            /**
             * Base URL that `Document` or `FrameOwner` node uses for URL completion.
             */
            baseURL: StringIndex;
            /**
             * Contains the document's content language.
             */
            contentLanguage: StringIndex;
            /**
             * Contains the document's character set encoding.
             */
            encodingName: StringIndex;
            /**
             * `DocumentType` node's publicId.
             */
            publicId: StringIndex;
            /**
             * `DocumentType` node's systemId.
             */
            systemId: StringIndex;
            /**
             * Frame ID for frame owner elements and also for the document node.
             */
            frameId: StringIndex;
            /**
             * A table with dom nodes.
             */
            nodes: NodeTreeSnapshot;
            /**
             * The nodes in the layout tree.
             */
            layout: LayoutTreeSnapshot;
            /**
             * The post-layout inline text nodes.
             */
            textBoxes: TextBoxSnapshot;
            /**
             * Horizontal scroll offset.
             */
            scrollOffsetX?: number;
            /**
             * Vertical scroll offset.
             */
            scrollOffsetY?: number;
            /**
             * Document content width.
             */
            contentWidth?: number;
            /**
             * Document content height.
             */
            contentHeight?: number;
        }

        /**
         * Table containing nodes.
         */
        export interface NodeTreeSnapshot {
            /**
             * Parent node index.
             */
            parentIndex?: integer[];
            /**
             * `Node`'s nodeType.
             */
            nodeType?: integer[];
            /**
             * Type of the shadow root the `Node` is in. String values are equal to the `ShadowRootType` enum.
             */
            shadowRootType?: RareStringData;
            /**
             * `Node`'s nodeName.
             */
            nodeName?: StringIndex[];
            /**
             * `Node`'s nodeValue.
             */
            nodeValue?: StringIndex[];
            /**
             * `Node`'s id, corresponds to DOM.Node.backendNodeId.
             */
            backendNodeId?: DOM.BackendNodeId[];
            /**
             * Attributes of an `Element` node. Flatten name, value pairs.
             */
            attributes?: ArrayOfStrings[];
            /**
             * Only set for textarea elements, contains the text value.
             */
            textValue?: RareStringData;
            /**
             * Only set for input elements, contains the input's associated text value.
             */
            inputValue?: RareStringData;
            /**
             * Only set for radio and checkbox input elements, indicates if the element has been checked
             */
            inputChecked?: RareBooleanData;
            /**
             * Only set for option elements, indicates if the element has been selected
             */
            optionSelected?: RareBooleanData;
            /**
             * The index of the document in the list of the snapshot documents.
             */
            contentDocumentIndex?: RareIntegerData;
            /**
             * Type of a pseudo element node.
             */
            pseudoType?: RareStringData;
            /**
             * Pseudo element identifier for this node. Only present if there is a
             * valid pseudoType.
             */
            pseudoIdentifier?: RareStringData;
            /**
             * Whether this DOM node responds to mouse clicks. This includes nodes that have had click
             * event listeners attached via JavaScript as well as anchor tags that naturally navigate when
             * clicked.
             */
            isClickable?: RareBooleanData;
            /**
             * The selected url for nodes with a srcset attribute.
             */
            currentSourceURL?: RareStringData;
            /**
             * The url of the script (if any) that generates this node.
             */
            originURL?: RareStringData;
        }

        /**
         * Table of details of an element in the DOM tree with a LayoutObject.
         */
        export interface LayoutTreeSnapshot {
            /**
             * Index of the corresponding node in the `NodeTreeSnapshot` array returned by `captureSnapshot`.
             */
            nodeIndex: integer[];
            /**
             * Array of indexes specifying computed style strings, filtered according to the `computedStyles` parameter passed to `captureSnapshot`.
             */
            styles: ArrayOfStrings[];
            /**
             * The absolute position bounding box.
             */
            bounds: Rectangle[];
            /**
             * Contents of the LayoutText, if any.
             */
            text: StringIndex[];
            /**
             * Stacking context information.
             */
            stackingContexts: RareBooleanData;
            /**
             * Global paint order index, which is determined by the stacking order of the nodes. Nodes
             * that are painted together will have the same index. Only provided if includePaintOrder in
             * captureSnapshot was true.
             */
            paintOrders?: integer[];
            /**
             * The offset rect of nodes. Only available when includeDOMRects is set to true
             */
            offsetRects?: Rectangle[];
            /**
             * The scroll rect of nodes. Only available when includeDOMRects is set to true
             */
            scrollRects?: Rectangle[];
            /**
             * The client rect of nodes. Only available when includeDOMRects is set to true
             */
            clientRects?: Rectangle[];
            /**
             * The list of background colors that are blended with colors of overlapping elements.
             */
            blendedBackgroundColors?: StringIndex[];
            /**
             * The list of computed text opacities.
             */
            textColorOpacities?: number[];
        }

        /**
         * Table of details of the post layout rendered text positions. The exact layout should not be regarded as
         * stable and may change between versions.
         */
        export interface TextBoxSnapshot {
            /**
             * Index of the layout tree node that owns this box collection.
             */
            layoutIndex: integer[];
            /**
             * The absolute position bounding box.
             */
            bounds: Rectangle[];
            /**
             * The starting index in characters, for this post layout textbox substring. Characters that
             * would be represented as a surrogate pair in UTF-16 have length 2.
             */
            start: integer[];
            /**
             * The number of characters in this post layout textbox substring. Characters that would be
             * represented as a surrogate pair in UTF-16 have length 2.
             */
            length: integer[];
        }

        export interface GetSnapshotRequest {
            /**
             * Whitelist of computed styles to return.
             */
            computedStyleWhitelist: string[];
            /**
             * Whether or not to retrieve details of DOM listeners (default false).
             */
            includeEventListeners?: boolean;
            /**
             * Whether to determine and include the paint order index of LayoutTreeNodes (default false).
             */
            includePaintOrder?: boolean;
            /**
             * Whether to include UA shadow tree in the snapshot (default false).
             */
            includeUserAgentShadowTree?: boolean;
        }

        export interface GetSnapshotResponse {
            /**
             * The nodes in the DOM tree. The DOMNode at index 0 corresponds to the root document.
             */
            domNodes: DOMNode[];
            /**
             * The nodes in the layout tree.
             */
            layoutTreeNodes: LayoutTreeNode[];
            /**
             * Whitelisted ComputedStyle properties for each node in the layout tree.
             */
            computedStyles: ComputedStyle[];
        }

        export interface CaptureSnapshotRequest {
            /**
             * Whitelist of computed styles to return.
             */
            computedStyles: string[];
            /**
             * Whether to include layout object paint orders into the snapshot.
             */
            includePaintOrder?: boolean;
            /**
             * Whether to include DOM rectangles (offsetRects, clientRects, scrollRects) into the snapshot
             */
            includeDOMRects?: boolean;
            /**
             * Whether to include blended background colors in the snapshot (default: false).
             * Blended background color is achieved by blending background colors of all elements
             * that overlap with the current element.
             */
            includeBlendedBackgroundColors?: boolean;
            /**
             * Whether to include text color opacity in the snapshot (default: false).
             * An element might have the opacity property set that affects the text color of the element.
             * The final text color opacity is computed based on the opacity of all overlapping elements.
             */
            includeTextColorOpacities?: boolean;
        }

        export interface CaptureSnapshotResponse {
            /**
             * The nodes in the DOM tree. The DOMNode at index 0 corresponds to the root document.
             */
            documents: DocumentSnapshot[];
            /**
             * Shared string table that all string properties refer to with indexes.
             */
            strings: string[];
        }
    }

    /**
     * Query and modify DOM storage.
     */
    export namespace DOMStorage {

        export type SerializedStorageKey = string;

        /**
         * DOM Storage identifier.
         */
        export interface StorageId {
            /**
             * Security origin for the storage.
             */
            securityOrigin?: string;
            /**
             * Represents a key by which DOM Storage keys its CachedStorageAreas
             */
            storageKey?: SerializedStorageKey;
            /**
             * Whether the storage is local storage (not session storage).
             */
            isLocalStorage: boolean;
        }

        /**
         * DOM Storage item.
         */
        export type Item = string[];

        export interface ClearRequest {
            storageId: StorageId;
        }

        export interface GetDOMStorageItemsRequest {
            storageId: StorageId;
        }

        export interface GetDOMStorageItemsResponse {
            entries: Item[];
        }

        export interface RemoveDOMStorageItemRequest {
            storageId: StorageId;
            key: string;
        }

        export interface SetDOMStorageItemRequest {
            storageId: StorageId;
            key: string;
            value: string;
        }

        export interface DomStorageItemAddedEvent {
            storageId: StorageId;
            key: string;
            newValue: string;
        }

        export interface DomStorageItemRemovedEvent {
            storageId: StorageId;
            key: string;
        }

        export interface DomStorageItemUpdatedEvent {
            storageId: StorageId;
            key: string;
            oldValue: string;
            newValue: string;
        }

        export interface DomStorageItemsClearedEvent {
            storageId: StorageId;
        }
    }

    export namespace Database {

        /**
         * Unique identifier of Database object.
         */
        export type DatabaseId = string;

        /**
         * Database object.
         */
        export interface Database {
            /**
             * Database ID.
             */
            id: DatabaseId;
            /**
             * Database domain.
             */
            domain: string;
            /**
             * Database name.
             */
            name: string;
            /**
             * Database version.
             */
            version: string;
        }

        /**
         * Database error.
         */
        export interface Error {
            /**
             * Error message.
             */
            message: string;
            /**
             * Error code.
             */
            code: integer;
        }

        export interface ExecuteSQLRequest {
            databaseId: DatabaseId;
            query: string;
        }

        export interface ExecuteSQLResponse {
            columnNames?: string[];
            values?: any[];
            sqlError?: Error;
        }

        export interface GetDatabaseTableNamesRequest {
            databaseId: DatabaseId;
        }

        export interface GetDatabaseTableNamesResponse {
            tableNames: string[];
        }

        export interface AddDatabaseEvent {
            database: Database;
        }
    }

    export namespace DeviceOrientation {

        export interface SetDeviceOrientationOverrideRequest {
            /**
             * Mock alpha
             */
            alpha: number;
            /**
             * Mock beta
             */
            beta: number;
            /**
             * Mock gamma
             */
            gamma: number;
        }
    }

    /**
     * This domain emulates different environments for the page.
     */
    export namespace Emulation {

        export const enum ScreenOrientationType {
            PortraitPrimary = 'portraitPrimary',
            PortraitSecondary = 'portraitSecondary',
            LandscapePrimary = 'landscapePrimary',
            LandscapeSecondary = 'landscapeSecondary',
        }

        /**
         * Screen orientation.
         */
        export interface ScreenOrientation {
            /**
             * Orientation type. (ScreenOrientationType enum)
             */
            type: ('portraitPrimary' | 'portraitSecondary' | 'landscapePrimary' | 'landscapeSecondary');
            /**
             * Orientation angle.
             */
            angle: integer;
        }

        export const enum DisplayFeatureOrientation {
            Vertical = 'vertical',
            Horizontal = 'horizontal',
        }

        export interface DisplayFeature {
            /**
             * Orientation of a display feature in relation to screen (DisplayFeatureOrientation enum)
             */
            orientation: ('vertical' | 'horizontal');
            /**
             * The offset from the screen origin in either the x (for vertical
             * orientation) or y (for horizontal orientation) direction.
             */
            offset: integer;
            /**
             * A display feature may mask content such that it is not physically
             * displayed - this length along with the offset describes this area.
             * A display feature that only splits content will have a 0 mask_length.
             */
            maskLength: integer;
        }

        export const enum DevicePostureType {
            Continuous = 'continuous',
            Folded = 'folded',
        }

        export interface DevicePosture {
            /**
             * Current posture of the device (DevicePostureType enum)
             */
            type: ('continuous' | 'folded');
        }

        export interface MediaFeature {
            name: string;
            value: string;
        }

        /**
         * advance: If the scheduler runs out of immediate work, the virtual time base may fast forward to
         * allow the next delayed task (if any) to run; pause: The virtual time base may not advance;
         * pauseIfNetworkFetchesPending: The virtual time base may not advance if there are any pending
         * resource fetches.
         */
        export type VirtualTimePolicy = ('advance' | 'pause' | 'pauseIfNetworkFetchesPending');

        /**
         * Used to specify User Agent Client Hints to emulate. See https://wicg.github.io/ua-client-hints
         */
        export interface UserAgentBrandVersion {
            brand: string;
            version: string;
        }

        /**
         * Used to specify User Agent Client Hints to emulate. See https://wicg.github.io/ua-client-hints
         * Missing optional values will be filled in by the target with what it would normally use.
         */
        export interface UserAgentMetadata {
            /**
             * Brands appearing in Sec-CH-UA.
             */
            brands?: UserAgentBrandVersion[];
            /**
             * Brands appearing in Sec-CH-UA-Full-Version-List.
             */
            fullVersionList?: UserAgentBrandVersion[];
            fullVersion?: string;
            platform: string;
            platformVersion: string;
            architecture: string;
            model: string;
            mobile: boolean;
            bitness?: string;
            wow64?: boolean;
        }

        /**
         * Used to specify sensor types to emulate.
         * See https://w3c.github.io/sensors/#automation for more information.
         */
        export type SensorType = ('absolute-orientation' | 'accelerometer' | 'ambient-light' | 'gravity' | 'gyroscope' | 'linear-acceleration' | 'magnetometer' | 'proximity' | 'relative-orientation');

        export interface SensorMetadata {
            available?: boolean;
            minimumFrequency?: number;
            maximumFrequency?: number;
        }

        export interface SensorReadingSingle {
            value: number;
        }

        export interface SensorReadingXYZ {
            x: number;
            y: number;
            z: number;
        }

        export interface SensorReadingQuaternion {
            x: number;
            y: number;
            z: number;
            w: number;
        }

        export interface SensorReading {
            single?: SensorReadingSingle;
            xyz?: SensorReadingXYZ;
            quaternion?: SensorReadingQuaternion;
        }

        /**
         * Enum of image types that can be disabled.
         */
        export type DisabledImageType = ('avif' | 'webp');

        export interface CanEmulateResponse {
            /**
             * True if emulation is supported.
             */
            result: boolean;
        }

        export interface SetFocusEmulationEnabledRequest {
            /**
             * Whether to enable to disable focus emulation.
             */
            enabled: boolean;
        }

        export interface SetAutoDarkModeOverrideRequest {
            /**
             * Whether to enable or disable automatic dark mode.
             * If not specified, any existing override will be cleared.
             */
            enabled?: boolean;
        }

        export interface SetCPUThrottlingRateRequest {
            /**
             * Throttling rate as a slowdown factor (1 is no throttle, 2 is 2x slowdown, etc).
             */
            rate: number;
        }

        export interface SetDefaultBackgroundColorOverrideRequest {
            /**
             * RGBA of the default background color. If not specified, any existing override will be
             * cleared.
             */
            color?: DOM.RGBA;
        }

        export interface SetDeviceMetricsOverrideRequest {
            /**
             * Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
             */
            width: integer;
            /**
             * Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
             */
            height: integer;
            /**
             * Overriding device scale factor value. 0 disables the override.
             */
            deviceScaleFactor: number;
            /**
             * Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text
             * autosizing and more.
             */
            mobile: boolean;
            /**
             * Scale to apply to resulting view image.
             */
            scale?: number;
            /**
             * Overriding screen width value in pixels (minimum 0, maximum 10000000).
             */
            screenWidth?: integer;
            /**
             * Overriding screen height value in pixels (minimum 0, maximum 10000000).
             */
            screenHeight?: integer;
            /**
             * Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
             */
            positionX?: integer;
            /**
             * Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
             */
            positionY?: integer;
            /**
             * Do not set visible view size, rely upon explicit setVisibleSize call.
             */
            dontSetVisibleSize?: boolean;
            /**
             * Screen orientation override.
             */
            screenOrientation?: ScreenOrientation;
            /**
             * If set, the visible area of the page will be overridden to this viewport. This viewport
             * change is not observed by the page, e.g. viewport-relative elements do not change positions.
             */
            viewport?: Page.Viewport;
            /**
             * If set, the display feature of a multi-segment screen. If not set, multi-segment support
             * is turned-off.
             */
            displayFeature?: DisplayFeature;
            /**
             * If set, the posture of a foldable device. If not set the posture is set
             * to continuous.
             * Deprecated, use Emulation.setDevicePostureOverride.
             */
            devicePosture?: DevicePosture;
        }

        export interface SetDevicePostureOverrideRequest {
            posture: DevicePosture;
        }

        export interface SetScrollbarsHiddenRequest {
            /**
             * Whether scrollbars should be always hidden.
             */
            hidden: boolean;
        }

        export interface SetDocumentCookieDisabledRequest {
            /**
             * Whether document.coookie API should be disabled.
             */
            disabled: boolean;
        }

        export const enum SetEmitTouchEventsForMouseRequestConfiguration {
            Mobile = 'mobile',
            Desktop = 'desktop',
        }

        export interface SetEmitTouchEventsForMouseRequest {
            /**
             * Whether touch emulation based on mouse input should be enabled.
             */
            enabled: boolean;
            /**
             * Touch/gesture events configuration. Default: current platform. (SetEmitTouchEventsForMouseRequestConfiguration enum)
             */
            configuration?: ('mobile' | 'desktop');
        }

        export interface SetEmulatedMediaRequest {
            /**
             * Media type to emulate. Empty string disables the override.
             */
            media?: string;
            /**
             * Media features to emulate.
             */
            features?: MediaFeature[];
        }

        export const enum SetEmulatedVisionDeficiencyRequestType {
            